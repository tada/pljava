<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2019-10-21 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PostgreSQL PL/Java &#x2013; Optionally-built example code for XML processing with Saxon</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20191021" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean">
                                                <img src="../images/pljava_logo.jpg" alt="PL/Java logo combining the PostgreSQL elephant and a Java bean" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2019-10-21</span>
                  &nbsp;| <span id="projectVersion">Version: 1.5.4</span>
                      </div>
            <div class="xright">                    <a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a>
            |
                        <a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a>
            |
                        <a href="http://lists.pgfoundry.org/pipermail/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a>
            |
                        <a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Usage</h5>
                  <ul>
                  <li class="none">
                          <a href="../build/build.html" title="Building PL/Java">Building PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a>
            </li>
                  <li class="none">
                          <a href="../install/upgrade.html" title="Upgrading">Upgrading</a>
            </li>
                  <li class="none">
                          <a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../use/use.html" title="User guide">User guide</a>
            </li>
                  <li class="none">
                          <a href="../develop/develop.html" title="Developer notes">Developer notes</a>
            </li>
          </ul>
                       <h5>Release Information</h5>
                  <ul>
                  <li class="none">
                          <a href="../releasenotes.html" title="Release notes">Release notes</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a>
            </li>
                  <li class="none">
                          <a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-deploy/index.html" title="PL/Java Deploy">PL/Java Deploy</a>
            </li>
                  <li class="none">
                          <a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a>
            </li>
                  <li class="none">
                          <a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a>
            </li>
                  <li class="none">
                          <a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2><a name="Optionally-built_example_code_for_XML_processing_with_Saxon"></a>Optionally-built example code for XML processing with Saxon</h2>
<p>In the source directory <tt>org/postgresql/pljava/example/saxon</tt> is example code for XML processing functions similar to <tt>XMLCAST</tt>, <tt>XMLEXISTS</tt>, <tt>XMLQUERY</tt>, and <tt>XMLTABLE</tt>, but using the XQuery language as the SQL/XML standard actually specifies (in contrast to similar functions built into PostgreSQL, which support only XPath, and XPath 1.0, at that).</p>
<p>The example also implements the four new string functions and one predicate added in SQL:2006 for regular expression processing using the standardized XQuery regular expression syntax: <tt>LIKE_REGEX</tt>, <tt>OCCURRENCES_REGEX</tt>, <tt>POSITION_REGEX</tt>, <tt>SUBSTRING_REGEX</tt>, and <tt>TRANSLATE_REGEX</tt>.</p>
<p>There is also, for completeness, an implementation of <tt>XMLTEXT</tt>, which is trivial and does not require an XQuery library at all, but is missing from core PostgreSQL and easy to implement here.</p>
<p>This code is not built by default, because it pulls in the sizeable <a class="externalLink" href="http://www.saxonica.com/html/products/products.html">Saxon-HE</a> library from Saxonica, and because (unlike the rest of PL/Java) it requires Java 8.</p>
<p>To include these optional functions when building the examples, be sure to use a Java 8 or later build environment, and add <tt>-Psaxon-examples</tt> to the <tt>mvn</tt> command line.</p>
<p>The functions are presented as examples, not as fully supported for production; for one thing, there is no test suite included to verify their conformance. Nevertheless, they are intended to be substantially usable subject to the limits described here, and testing and reports of shortcomings are welcome.</p>
<p>In addition to the open-source and freely-licensed Saxon-HE, the Saxon library is available in two paid editions, which implement more of the features of XQuery 3.1 than Saxon-HE does. It should be possible to drop either of those jar files in place of Saxon-HE (with a working license key) if features are needed beyond what Saxon-HE provides. Its developers publish <a class="externalLink" href="https://www.saxonica.com/html/products/feature-matrix-9-9.html">a matrix</a> identifying the features provided in each edition.</p>
<div class="section">
<h3><a name="Extension_to_ISO_SQLXML"></a>Extension to ISO SQL/XML</h3>
<p>Wherever ISO SQL/XML requires one of these functions to accept an XQuery <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#id-expressions">expression</a>, in fact an XQuery <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#dt-main-module">main module</a> will be accepted. Therefore, a query can be preceded by a prolog that declares namespaces, options, local variables and functions, etc. This may simplify porting queries from Oracle, which permits the same extension.</p></div>
<div class="section">
<h3><a name="Using_the_Saxon_examples"></a>Using the Saxon examples</h3>
<p>The simplest installation method is to use <tt>sqlj.install_jar</tt> twice, once to install the PL/Java examples jar in the usual way (perhaps with the name <tt>ex</tt> and with <tt>deploy =&gt; true</tt>), and once to install (perhaps with the name <tt>saxon</tt>) the Saxon-HE jar that Maven will have downloaded during the build. That jar will be found in your Maven repository (likely <tt>~/.m2/repository/</tt> unless you have directed it elsewhere) below the path <tt>net/sf/saxon</tt>.</p>
<p>Then use <tt>sqlj.set_classpath</tt> to set a path including both jars (<tt>'ex:saxon'</tt> if you used the names suggested above).</p></div>
<div class="section">
<h3><a name="Calling_XML_functions_without_SQL_syntactic_sugar"></a>Calling XML functions without SQL syntactic sugar</h3>
<p>The XML querying and <tt>XMLTABLE</tt> functions built into PostgreSQL get special treatment from the SQL parser to give them syntax that is more SQLish than an ordinary function call.</p>
<p>The functions provided here have to work as ordinary SQL user-defined functions, so calls to them can look a bit more verbose when written out in SQL, but in a way that can be recognized as a straightforward rewriting of the SQLish standard syntax.</p>
<p>For example, suppose there is a table <tt>catalog_as_xml</tt> with a single row whose <tt>x</tt> column is a (respectably sized) XML document recording the stuff in <tt>pg_catalog</tt>. It could be created like this:</p>

<div class="source">
<div class="source">
<pre>CREATE TABLE catalog_as_xml(x) AS
  SELECT schema_to_xml('pg_catalog', false, true, '');
</pre></div></div>
<div class="section">
<h4><a name="An_XMLQUERY-like_function"></a>An <tt>XMLQUERY</tt>-like function</h4>
<p>In the syntax of the SQL/XML standard, here is a query that would return an XML element representing the declaration of the function with the name <tt>numeric_avg</tt> (if PostgreSQL really had the standard <tt>XMLQUERY</tt> function built in):</p>

<div class="source">
<div class="source">
<pre>SELECT XMLQUERY('/pg_catalog/pg_proc[proname eq $FUNCNAME]'
                PASSING BY VALUE x, 'numeric_avg' AS FUNCNAME
                RETURNING CONTENT EMPTY ON EMPTY)
FROM catalog_as_xml;
</pre></div></div>
<p>It binds the &#x2018;context item&#x2019; of the query to <tt>x</tt>, and the <tt>FUNCNAME</tt> parameter to the given value, then evaluates the query and returns XML &#x201c;CONTENT&#x201d; (a tree structure with a document node at the root, but not necessarily meeting all the requirements of an XML &#x201c;DOCUMENT&#x201d;). It can be rewritten as this call to the <tt>xq_ret_content</tt> method provided here:</p>

<div class="source">
<div class="source">
<pre>SELECT javatest.xq_ret_content('/pg_catalog/pg_proc[proname eq $FUNCNAME]',
                               PASSING =&gt; p, nullOnEmpty =&gt; false)
FROM catalog_as_xml,
LATERAL (SELECT x AS &quot;.&quot;, 'numeric_avg' AS &quot;FUNCNAME&quot;) AS p;
</pre></div></div>
<p>In the rewritten form, the type of value returned is determined by which function is called, and the parameters to pass to the query are moved out to a separate <tt>SELECT</tt> that supplies their values, types, and names (with the context item now given the name &#x201c;.&#x201d;) and is passed by its alias into the query function.</p>
<p>An alert reader may notice that the example above includes a named parameter, <tt>FUNCNAME</tt>, and it is spelled in uppercase in the XQuery expression that uses it, and is spelled in uppercase <i>and quoted</i> in the sub-<tt>SELECT</tt> that supplies it. The reason is an unconditional <tt>toUppercase()</tt> in PL/Java&#x2019;s internal JDBC driver, which is not anything the JDBC standard requires, but has been there in PL/Java since 2005. For now, therefore, no matter how a parameter name is spelled in the sub-<tt>SELECT</tt>, it must appear in uppercase in the XQuery expression using it, or it will not be recognized. A future PL/Java release is highly likely to stop forcibly uppercasing the names. At that time, any code relying on the uppercasing will break. Therefore, it is wisest, until then, to call this function with all parameter names spelled in uppercase both in the SQL and in the XQuery text, and on the SQL side that requires quoting the name to avoid the conventional lowercasing done by PostgreSQL.</p>
<p>In the standard, parameters and results (of XML types) can be passed <tt>BY VALUE</tt> or <tt>BY REF</tt>, where the latter means that the same nodes will retain their XQuery node identities over calls (note that this is a meaning unrelated to what &#x201c;by value&#x201d; and &#x201c;by reference&#x201d; usually mean in PostgreSQL&#x2019;s documentation). PostgreSQL&#x2019;s implementation of the XML type provides no way for <tt>BY REF</tt> semantics to be implemented, so everything happening here happens <tt>BY VALUE</tt> implicitly, and does not need to be specified.</p></div>
<div class="section">
<h4><a name="An_XMLEXISTS-like_predicate"></a>An <tt>XMLEXISTS</tt>-like predicate</h4>
<p>In the syntax of the SQL/XML standard, here is a query that would return a boolean result indicating whether an SQL function named <tt>numeric_avg</tt> is declared (if PostgreSQL really had the standard <tt>XMLEXISTS</tt> function built in):</p>

<div class="source">
<div class="source">
<pre>SELECT XMLEXISTS('/pg_catalog/pg_proc[proname eq $FUNCNAME]'
                 PASSING BY VALUE x, 'numeric_avg' AS FUNCNAME)
FROM catalog_as_xml;
</pre></div></div>
<p>It can be rewritten as this call to the <tt>xmlexists</tt> method provided here:</p>

<div class="source">
<div class="source">
<pre>SELECT &quot;xmlexists&quot;('/pg_catalog/pg_proc[proname eq $FUNCNAME]',
                   PASSING =&gt; p)
FROM catalog_as_xml,
LATERAL (SELECT x AS &quot;.&quot;, 'numeric_avg' AS &quot;FUNCNAME&quot;) AS p;
</pre></div></div>
<p>As for the <tt>XMLQUERY</tt>-like function above, , the context item and a parameter are supplied by a separate query producing the row <tt>p</tt> that is given as the <tt>PASSING</tt> argument to <tt>&quot;xmlexists&quot;</tt>. The parameter name is capitalized for the reasons explained above for the <tt>XMLQUERY</tt>-like function.</p></div>
<div class="section">
<h4><a name="An_XMLTABLE-like_function"></a>An <tt>XMLTABLE</tt>-like function</h4>
<p>The function <tt>xmltable</tt> here implements (much of) the standard function of the same name. Because it is the same name, it has to be either schema-qualified or double-quoted in a call to avoid confusion with the reserved word. A rewritten form of the <a class="externalLink" href="https://www.postgresql.org/docs/10/static/functions-xml.html#FUNCTIONS-XML-PROCESSING-XMLTABLE">first example in the PostgreSQL manual</a> could be:</p>

<div class="source">
<div class="source">
<pre>SELECT xmltable.*
FROM
  xmldata,

  LATERAL (SELECT data AS &quot;.&quot;, 'not specified'::text AS &quot;DPREMIER&quot;) AS p,

  &quot;xmltable&quot;('//ROWS/ROW', PASSING =&gt; p, COLUMNS =&gt; ARRAY[
   'data(@id)', null, 'COUNTRY_NAME',
   'COUNTRY_ID', 'SIZE[@unit eq &quot;sq_km&quot;]',
   'concat(SIZE[@unit ne &quot;sq_km&quot;], &quot; &quot;, SIZE[@unit ne &quot;sq_km&quot;]/@unit)',
   'let $e := PREMIER_NAME
    return if ( empty($e) ) then $DPREMIER else $e'
  ]) AS (
   id int, ordinality int, &quot;COUNTRY_NAME&quot; text, country_id text,
   size_sq_km float, size_other text, premier_name text
  );
</pre></div></div>
<p>Again, the context item and a parameter (here the desired default value for <tt>PREMIER</tt>, passed in as the parameter <tt>DPREMIER</tt>) are supplied by a separate query producing the row <tt>p</tt> that is given as <tt>&quot;xmltable&quot;</tt>&#x2019;s <tt>PASSING</tt> argument. The result column names and types are now specified in the <tt>AS</tt> list following the function call, and the column XML Query expressions are supplied as the <tt>COLUMNS</tt> array. The array must have length equal to the result column <tt>AS</tt> list (there is no defaulting an omitted column expression to an element test using the column&#x2019;s name, as there is in the standard function). The array is allowed to have one null element, marking that column <tt>FOR ORDINALITY</tt>.</p>
<p>The parameter being passed into the XQuery expressions here, <tt>DPREMIER</tt>, is spelled in uppercase (and, on the SQL side, quoted), for the reasons explained above for the <tt>XMLQUERY</tt>-like function.</p>
<p>In the first column expression, <tt>@id</tt> is wrapped in <tt>data()</tt> to return the value of the attribute, as <tt>@id</tt> by itself would be a bare XML attribute node, outside of any XML element. Many implementations (including the XPath-based pseudo-XMLTABLE built in to PostgreSQL) will allow a bare attribute node in a column expression result, and assume the attribute&#x2019;s value is wanted, but a strict interpretation of the spec appears to require raising <tt>err:XPTY0004</tt> in that case. So, just use <tt>data()</tt> to wrap any attribute node being returned in a column expression.</p>
<p>More on that issue and the spec can be found at &#x201c;About bare attribute nodes&#x201d; <a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#assignRowValues-java.sql.ResultSet-int-">in the code comments</a>.</p></div>
<div class="section">
<h4><a name="An_XMLCAST-like_function"></a>An <tt>XMLCAST</tt>-like function</h4>
<p>The ISO SQL <tt>XMLCAST</tt> is used to convert XML content into a value of an SQL data type, or an SQL value to an XML value, following the same precisely-specified conversion rules that are used for the parameters and results of the <tt>XMLQUERY</tt> and <tt>XMLTABLE</tt> functions. It can also convert from one XML type to another, though in PostgreSQL, which has just one XML type, the conversion is trivial. In a DBMS with support for the full set of XML types such as <tt>XML(CONTENT)</tt>, <tt>XML(DOCUMENT)</tt>, and <tt>XML(SEQUENCE)</tt>, the rules for casting one to another are more interesting.</p>
<p>This ordinary-function implementation of <tt>XMLCAST</tt> is used by rewriting an SQL standard form like</p>

<div class="source">
<div class="source">
<pre>SELECT XMLCAST(value AS wantedtype)
</pre></div></div>
<p>into a form like</p>

<div class="source">
<div class="source">
<pre>SELECT result FROM (select value) as v, &quot;xmlcast&quot;(v) AS (result wantedtype)
</pre></div></div>
<p>where either: <i>value</i> is of <tt>xml</tt> type, <i>wantedtype</i> is <tt>xml</tt>, or both; in other words, the only case <tt>XMLCAST</tt> does not handle is where neither the input nor result is of <tt>xml</tt> type. Because casting XML to XML is not exciting in PostgreSQL, the most useful cases are XML to another SQL type, or the reverse.</p></div>
<div class="section">
<h4><a name="The_ISO_SQL_XQuery_regular_expression_features"></a>The ISO SQL XQuery regular expression features</h4>
<p>The SQL standard specifies a string predicate, <tt>LIKE_REGEX</tt>, for testing a string against an <a class="externalLink" href="https://www.w3.org/TR/xpath-functions-31/#regex-syntax">XQuery regular expression</a> (an extension of <a class="externalLink" href="https://www.w3.org/TR/xmlschema-2/#regexs">XML Schema regular expression syntax</a>), and four string functions also based on XQuery regular expressions: <tt>OCCURRENCES_REGEX</tt>, <tt>POSITION_REGEX</tt>, <tt>SUBSTRING_REGEX</tt>, and <tt>TRANSLATE_REGEX</tt>.</p>
<p>The &#x201c;flags&#x201d; parameter to any of these can include any of the <a class="externalLink" href="https://www.w3.org/TR/xpath-functions-31/#flags">XQuery regular expression flags <tt>s</tt>, <tt>m</tt>, <tt>i</tt>, <tt>x</tt>, and <tt>q</tt></a>.</p>
<p>As with the <tt>XMLQUERY</tt> and <tt>XMLTABLE</tt> functions, some straightforward rewriting is needed from the SQL-standard syntax into calls of these ordinary functions.</p>
<p>In the current implementation, all of these functions recognize newlines in the way specified by XQuery, not the modified way specified for ISO SQL, as further explained below after the function descriptions. To leave a clear path to a full implementation, these versions all accept an additional parameter <tt>w3cNewlines</tt>, which must always be present, for now, as <tt>w3cNewlines =&gt; true</tt>. Specifying <tt>false</tt>, or omitting this parameter, will mean the ISO SQL newline treatment is wanted, and will be rejected as an unsupported feature in this implementation.</p>
<p>To avoid clutter, the <tt>w3cNewlines =&gt; true</tt> is not shown in the examples below.</p>
<div class="section">
<h5><a name="LIKE_REGEX"></a><a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#like_regex-java.lang.String-java.lang.String-java.lang.String-boolean-"><tt>LIKE_REGEX</tt></a></h5>
<p>A predicate that is <tt>true</tt> if a string matches the regular expression. The standard syntaxes</p>

<div class="source">
<div class="source">
<pre>value LIKE_REGEX pattern
value LIKE_REGEX pattern FLAG flags
</pre></div></div>
<p>can be rewritten to</p>

<div class="source">
<div class="source">
<pre>like_regex(value, pattern)
like_regex(value, pattern, flags)
like_regex(value, pattern, flag =&gt; flags)
</pre></div></div></div>
<div class="section">
<h5><a name="OCCURRENCES_REGEX"></a><a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#occurrences_regex-java.lang.String-java.lang.String-java.lang.String-int-boolean-boolean-"><tt>OCCURRENCES_REGEX</tt></a></h5>
<p>A function to count the occurrences of a pattern in a string. The count can start from a specific position in the string (the first character has position 1), and the position can be counted using Unicode characters, or using octets of the string&#x2019;s encoded form. For now, only <tt>USING CHARACTERS</tt> is implemented, which can be indicated by passing <tt>usingOctets =&gt; false</tt> or simply omitting it, as <tt>false</tt> is the default. Standard syntax examples like</p>

<div class="source">
<div class="source">
<pre>OCCURRENCES_REGEX(pattern IN str)
OCCURRENCES_REGEX(pattern FLAG flags IN str)
OCCURRENCES_REGEX(pattern IN str FROM position USING CHARACTERS)
</pre></div></div>
<p>can be rewritten to</p>

<div class="source">
<div class="source">
<pre>occurrences_regex(pattern, str)
occurrences_regex(pattern, flag =&gt; flags, &quot;in&quot; =&gt; str)
occurrences_regex(pattern, str, &quot;from&quot; =&gt; position)
</pre></div></div></div>
<div class="section">
<h5><a name="POSITION_REGEX"></a><a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#position_regex-java.lang.String-java.lang.String-java.lang.String-int-boolean-boolean-int-int-boolean-"><tt>POSITION_REGEX</tt></a></h5>
<p>A function to return the position of a regular expression match in a string, which can optionally return the position of a specific occurrence of the match (the first, if not specified), or of a particular capturing group within the desired match. The position reported can be of the first character of the match of interest (<tt>START</tt>), or of the first character following the match (<tt>AFTER</tt>). As for <tt>OCCURRENCES_REGEX</tt>, all positions can be expressed <tt>USING CHARACTERS</tt> or <tt>USING OCTETS</tt>, but only the default <tt>USING CHARACTERS</tt> is implemented here.</p>
<p>Standard syntax examples like</p>

<div class="source">
<div class="source">
<pre>POSITION_REGEX(START pattern IN str)
POSITION_REGEX(AFTER pattern IN str)
POSITION_REGEX(START pattern IN str OCCURRENCE n)
POSITION_REGEX(START pattern IN str OCCURRENCE n GROUP m)
POSITION_REGEX(START pattern IN str FROM pos OCCURRENCE n GROUP m)
</pre></div></div>
<p>can be rewritten to</p>

<div class="source">
<div class="source">
<pre>position_regex(pattern, str)
position_regex(pattern, str, after =&gt; true)
position_regex(pattern, str, occurrence =&gt; n)
position_regex(pattern, str, occurrence =&gt; n, &quot;group&quot; =&gt; m)
position_regex(pattern, str, &quot;from&quot; =&gt; pos, occurrence =&gt; n, &quot;group&quot; =&gt; m)
</pre></div></div>
<p>The result is always relative to the start of the string, not the starting position. That is, <tt>POSITION_REGEX('d' IN 'abcdef' FROM 3)</tt> is 4, not 2.</p></div>
<div class="section">
<h5><a name="SUBSTRING_REGEX"></a><a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#substring_regex-java.lang.String-java.lang.String-java.lang.String-int-boolean-int-int-boolean-"><tt>SUBSTRING_REGEX</tt></a></h5>
<p>Returns the substring that matched the regular expression, or a specific occurrence of the expression, or a specific capturing group within the desired occurrence. Standard syntax examples like</p>

<div class="source">
<div class="source">
<pre>SUBSTRING_REGEX(pattern IN str)
SUBSTRING_REGEX(pattern FLAG flags IN str)
SUBSTRING_REGEX(pattern IN str FROM position)
SUBSTRING_REGEX(pattern IN str OCCURRENCE n GROUP m)
</pre></div></div>
<p>can be rewritten to</p>

<div class="source">
<div class="source">
<pre>substring_regex(pattern, str)
substring_regex(pattern, flag =&gt; flags, &quot;in&quot; =&gt; str)
substring_regex(pattern, str, &quot;from&quot; =&gt; position)
substring_regex(pattern, str, occurrence =&gt; n, &quot;group&quot; =&gt; m)
</pre></div></div></div>
<div class="section">
<h5><a name="TRANSLATE_REGEX"></a><a href="../pljava-examples/apidocs/org/postgresql/pljava/example/saxon/S9.html#translate_regex-java.lang.String-java.lang.String-java.lang.String-java.lang.String-int-boolean-int-boolean-"><tt>TRANSLATE_REGEX</tt></a></h5>
<p>Returns a string built from the input string by replacing one specified occurrence, or all occurrences, of a matching pattern. The replacement text can include <tt>$0</tt> to include the entire substring that matched, or <tt>$</tt><i>n</i> for <i>n</i> a digit 1 through 9, to include what matched a capturing group in the pattern. The default behavior of replacing all occurrences applies when <tt>occurrence</tt> is not specified.</p>
<p>Standard syntax examples like</p>

<div class="source">
<div class="source">
<pre>TRANSLATE_REGEX(pattern IN str WITH repl)
TRANSLATE_REGEX(pattern IN str WITH repl OCCURRENCE n)
TRANSLATE_REGEX(pattern FLAG flags IN str WITH repl)
TRANSLATE_REGEX(pattern IN str WITH repl FROM position)
</pre></div></div>
<p>can be rewritten to</p>

<div class="source">
<div class="source">
<pre>translate_regex(pattern, str, &quot;with&quot; =&gt; repl)
translate_regex(pattern, str, &quot;with&quot; =&gt; repl, occurrence =&gt; n)
translate_regex(pattern, flag =&gt; flags, &quot;in&quot; =&gt; str, &quot;with&quot; =&gt; repl)
translate_regex(pattern, str, &quot;with&quot; =&gt; repl, &quot;from&quot; =&gt; position)
</pre></div></div></div>
<div class="section">
<h5><a name="Recognition_of_newlines"></a>Recognition of newlines</h5>
<p>A standard XQuery library provides regular expressions that follow the W3C XQuery rules for newline recognition, in which the <tt>^</tt> and <tt>$</tt> anchors recognize only the <tt>LINE FEED</tt> character, <tt>U&amp;'\000a'</tt>, the <tt>.</tt> metacharacter in non-<tt>dotall</tt> mode matches anything other than a <tt>LINE FEED</tt> or <tt>CARRIAGE RETURN</tt> <tt>U&amp;'\000d'</tt>, the <tt>\s</tt> multicharacter escape matches only those two characters plus space and horizontal tab, and <tt>\S</tt> is the exact complement of <tt>\s</tt>.</p>
<p>The ISO SQL specification for these XQuery regular expression features contains a modification of those rules to conform instead to <a class="externalLink" href="http://www.unicode.org/reports/tr18/#RL1.6">Unicode Technical Standard 18 rule 1.6</a>, in which several more Unicode characters are recognized as line boundaries, plus the two-character sequence <tt>CARRIAGE RETURN</tt> <tt>LINE FEED</tt> (which counts only as one line boundary). The modified meaning of <tt>\S</tt> becomes &#x201c;any <i>single</i> character that is not matched by a <i>single</i> character that matches&#x201d; <tt>\s</tt> (emphasis added), leaving it no longer the exact complement of <tt>\s</tt>.</p>
<p>It is difficult to implement the ISO SQL behavior over a standard XQuery library, so this implementation, for now, does not do so. All of these functions implement the standard W3C XQuery behavior, which can be &#x201c;requested&#x201d; by passing <tt>w3cNewlines =&gt; true</tt>. Without <tt>w3cNewlines =&gt; true</tt>, the call will be interpreted as intending the ISO SQL behavior, and an <tt>SQLFeatureNotSupportedException</tt> (SQLSTATE <tt>0A000</tt>) will be raised.</p></div>
<div class="section">
<h5><a name="Nonstandard_features"></a>Nonstandard features</h5>
<p>The Saxon XQuery library, implemented in Java, offers the ability to use Java regular expressions rather than XQuery ones, by passing a <i>flag</i> argument that ends with <tt>;j</tt> (an invalid flag string per the XQuery spec). This should not be used in code that intends to be standards-conformant or to run on another DBMS or XQuery library, but can be useful in some cases for features that Java regular expressions offer (such as lookahead and lookbehind predicates) that XQuery regular expressions do not.</p>
<div class="section">
<h6><a name="Java_regular_expressions_and_empty-match_replacements"></a>Java regular expressions and empty-match replacements</h6>
<p>This example implementation of <tt>TRANSLATE_REGEX</tt> will detect when a Java expression rather than an XQuery one is being used, and will then permit replacement of a zero-length match, rather than raising error <tt>2201U</tt> as the standard requires. As Java regular expressions include zero-width lookahead and lookbehind operators, a Java regex can usefully locate zero-width sites for replacements to be applied.</p>
<p>There are still subtleties involved. A site that is identified by <i>negative</i> lookahead or lookbehind operators (<tt>(?!)</tt> and <tt>(?&lt;!)</tt>) will be replaced as expected, but if the positive forms were used (<tt>(?=)</tt> and <tt>(?&lt;=)</tt>), the replacement will not occur. This example might be expected to insert <tt>!</tt> for the empty string between <tt>o</tt> and <tt>b</tt>, but does not:</p>

<div class="source">
<div class="source">
<pre>SELECT translate_regex('(?&lt;=o)(?=b)', 'foobar', &quot;with&quot; =&gt; '!',
                       flag =&gt; ';j', w3cNewlines =&gt; true);
 translate_regex 
-----------------
 foobar
</pre></div></div>
<p>The reason is that the specification of <tt>TRANSLATE_REGEX</tt> is as if the matched substring, here an empty string, is matched again <i>in isolation</i> against the original regex to do the replacement, and that empty string no longer has the <tt>o</tt> and <tt>b</tt> that the original lookbehind and lookahead matched. It can be made to work by adding an alternative that matches a truly empty string (<tt>\A\z</tt> in Java syntax):</p>

<div class="source">
<div class="source">
<pre>SELECT translate_regex('(?&lt;=o)(?=b)|\A\z', 'foobar', &quot;with&quot; =&gt; '!',
                       flag =&gt; ';j', w3cNewlines =&gt; true);
 translate_regex 
-----------------
 foo!bar
</pre></div></div>
<p>That workaround would also cause the replacement to happen if the input string is completely empty to start with, which might not be what&#x2019;s wanted.</p></div></div></div>
<div class="section">
<h4><a name="Syntax_in_older_PostgreSQL_versions"></a>Syntax in older PostgreSQL versions</h4>
<p>The desugared syntax shown above can be used in PostgreSQL versions as old as 9.5. In 9.4 and 9.3, the same syntax, but with <tt>=&gt;</tt> replaced by <tt>:=</tt> for the named parameters, can be used. The functions remain usable in still earlier PostgreSQL versions, but with increasingly convoluted SQL syntax needed to call them; before 9.3, for example, there was no <tt>LATERAL</tt> in a <tt>SELECT</tt>, and a function could not refer to earlier <tt>FROM</tt> items. Before 9.0, named-parameter notation can&#x2019;t be used in function calls. Before 8.4, the functions would have to be declared without their <tt>DEFAULT</tt> clauses and the <tt>IntervalStyle</tt> settings, and would not work with PostgreSQL interval values.</p></div></div>
<div class="section">
<h3><a name="Minimizing_startup_time"></a>Minimizing startup time</h3>
<p>Saxon is a large library, and benefits greatly from precompilation into a memory-mappable persistent cache, using the <a href="../install/appcds.html">application class data sharing</a> feature in Oracle Java or in OpenJDK with Hotspot, or the <a href="../install/oj9vmopt.html#How_to_set_up_class_sharing_in_OpenJ9">class sharing</a> feature in OpenJDK with OpenJ9.</p>
<p>The OpenJ9 feature is simpler to set up. Because it can cache classes straight from PL/Java installed jars, the setup can be done exactly as described above, and the OpenJ9 class sharing, if enabled, will just work. OpenJ9 class-sharing setup <a href="../install/oj9vmopt.html#How_to_set_up_class_sharing_in_OpenJ9">instructions are here</a>.</p>
<p>The Hotspot <tt>AppCDS</tt> feature is more work to set up, and can only cache classes on the JVM system classpath, so the Saxon jar would have to be installed on the filesystem and named in <tt>pljava.classpath</tt> instead of simply installing it in PL/Java. It also needs to be stripped of its <tt>jarsigner</tt> metadata, which the Hotspot <tt>AppCDS</tt> can&#x2019;t handle. Hotspot <tt>AppCDS</tt> setup <a href="../install/appcds.html">general instructions are here</a>, and specific details for setting up this example for <tt>AppCDS</tt> can be found on the <a class="externalLink" href="https://github.com/tada/pljava/wiki/Performance-tuning">performance-tuning wiki page</a> in the section devoted to it.</p>
<p>A comparison shown on that performance-tuning page appears to give Hotspot a significant advantage for a Saxon-heavy workload, so the more complex Hotspot setup may remain worthwhile as long as that comparison holds.</p>
<p>The <tt>AppCDS</tt> feature in Oracle Java is still (when last checked) a commercial feature, not to be used in production without a specific license from Oracle. OpenJDK, as of Java 10, ships Hotspot with the same feature included, without the encumbrance.</p></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2003&#x2013;2019
                        <a href="http://tada.se/eng/">Tada AB</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
