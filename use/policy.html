<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/use/policy.md at 2023-06-13

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>PostgreSQL PL/Java &#x2013; Configuring permissions in PL/Java</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean"><img src="../images/pljava_logo.jpg"  alt="PL/Java logo combining the PostgreSQL elephant and a Java bean"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2023-06-13</span>
          &#xA0;| <span id="projectVersion">Version: 1.6.5</span>
      </div>
      <div class="xright"><a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a> |
<a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a> |
<a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a> |
<a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Usage</h5>
    <ul>
     <li class="none"><a href="../build/build.html" title="Building PL/Java">Building PL/Java</a></li>
     <li class="none"><a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a></li>
     <li class="none"><a href="../install/upgrade.html" title="Upgrading">Upgrading</a></li>
     <li class="none"><a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a></li>
     <li class="none"><a href="../use/use.html" title="User guide">User guide</a></li>
     <li class="none"><a href="../develop/develop.html" title="Developer notes">Developer notes</a></li>
    </ul>
       <h5>Release Information</h5>
    <ul>
     <li class="none"><a href="../releasenotes.html" title="Release notes">Release notes</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a></li>
     <li class="none"><a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a></li>
     <li class="none"><a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a></li>
     <li class="none"><a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a></li>
     <li class="none"><a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a></li>
     <li class="none"><a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a></li>
     <li class="none"><a href="../pljava-pgxs/index.html" title="PL/Java PGXS">PL/Java PGXS</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="../project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>Configuring permissions in PL/Java</h1><section>
<h2><a name="TRUSTED_.28and_untrusted.29_procedural_languages"></a><code>TRUSTED</code> (and untrusted) procedural languages</h2>
<p>PostgreSQL allows a procedural language to be installed with or without the designation <code>TRUSTED</code>. For a language designated <code>TRUSTED</code>, functions can be created in that language by any user (PostgreSQL role) with <code>USAGE</code> permission on that language, as configured with the SQL commands <code>GRANT USAGE ON LANGUAGE ...</code> and <code>REVOKE USAGE ON LANGUAGE ...</code>. For a language that is <i>not</i> designated <code>TRUSTED</code>, only a database superuser may create functions that use it, no matter who has been granted <code>USAGE</code> on it.</p>
<p>In either case, once any function has been created, that function may be executed by any user/role granted <code>EXECUTE</code> permission on the function itself; a language&#x2019;s <code>USAGE</code> privilege (plus superuser status, if the language is not <code>TRUSTED</code>) is only needed to create a function that uses the language.</p>
<p>Because PL functions execute in the database server, a general-purpose programming language with no restrictions on access to its containing process or the server file system may be used for actions or access that PostgreSQL would normally not permit. A superuser can implement such a function using a non-<code>TRUSTED</code> PL, and design the function to enforce its own limits and be safe for use by whatever roles will be granted <code>EXECUTE</code> permission on it.</p>
<p>A <code>TRUSTED</code> PL is expected to enforce appropriate restrictions so that non-superusers can be allowed to use it to create functions on their own, while still subject to PostgreSQL&#x2019;s normal protections.</p>
<p>Both kinds have their uses, and many of the available PLs, including PL/Java, install two similarly-named &#x2018;languages&#x2019; to permit both. Although either can be renamed, a normal installation of PL/Java will create the language <code>java</code> with the <code>TRUSTED</code> property, and <code>javaU</code> without it.</p>
<p><i>Note: like any SQL identifier, these language names are case-insensitive when not quoted, and are stored in lowercase in PostgreSQL. The spelling with capital <code>U</code> for untrusted is a common convention.</i></p><section>
<h3><a name="TRUSTED.2Funtrusted_versus_sandboxed.2Funsandboxed"></a><code>TRUSTED</code>/untrusted versus sandboxed/unsandboxed</h3>
<p>In various places in PL/Java&#x2019;s API, and in the sections below, the words &#x2018;sandboxed&#x2019; or &#x2018;unsandboxed&#x2019; are used in place of the PostgreSQL <code>TRUSTED</code> or untrusted, respectively. That choice reflects a little trick of language some readers may notice when new to PostgreSQL: it is about equally easy to read &#x2018;trusted&#x2019;/&#x2018;untrusted&#x2019; in two opposite ways. (Is this language trusted because of how tightly I restrict it? Or do I restrict it less tightly because I trust it? Is it like a teenager with the car keys?) Old hands at PostgreSQL know which reading is correct, but because some users of PL/Java may be old hands at Java and newcomers to PostgreSQL, it seems safer for PL/Java to use terms that should give the right idea to readers in both groups.</p></section></section><section>
<h2><a name="Permissions_available_in_sandboxed.2Funsandboxed_PL.2FJava"></a>Permissions available in sandboxed/unsandboxed PL/Java</h2>
<p>Most PLs that offer both variants, including PL/Java before 1.6, hardcode the differences between what a function in each language is allowed to do. The sandboxed language would apply a fixed set of limitations, such as forbidding access to the server&#x2019;s file system, and those limits were not adjustable.</p>
<p>A needed function that would only access one, specific, known-safe file, or perhaps would need no file access but have to make a network connection to one known server, might <i>almost</i> be written under those predetermined restrictions, but that wouldn&#x2019;t count. It would simply have to be created for the unsandboxed language instead, and written defensively against a much wider range of possible misuses or mistakes.</p>
<p>Beginning with 1.6, PL/Java takes a more configurable approach. Using the Java <a class="externalLink" href="https://docs.oracle.com/en/java/javase/14/security/permissions-jdk1.html#GUID-7942E6F8-8AAB-4404-9FE9-E08DD6FFCFFA">policy file syntax</a>, any of the permissions known to the JDK can be granted to chosen Java code. The default policy file installed with PL/Java includes these lines:</p>

<div class="source">
<div class="source">
<pre>grant principal org.postgresql.pljava.PLPrincipal$Sandboxed * {
};

grant principal org.postgresql.pljava.PLPrincipal$Unsandboxed * {

    // Java does not circumvent operating system access controls;
    // this grant will still be limited to what the OS allows a
    // PostgreSQL backend process to do.
    permission java.io.FilePermission
        &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,write,delete,readlink&quot;;
};
</pre></div></div>

<p>A few observations fall out. Whatever the names may suggest, neither alternative is truly &#x201c;unsandboxed&#x201d;. Both are subject to the same Java policy, but can be granted different permissions within it.</p>
<p>As distributed, the only difference between the two is access to the filesystem. The &#x201c;sandboxed&#x201d; case grants no additional permissions at all, and the &#x201c;unsandboxed&#x201d; case adds read, readlink, write, and delete permission for any file (still subject to the operating system permissions in effect for the PostgreSQL server process, which will be enforced independently of Java).</p>
<p>The permissions granted for either case are freely configurable. Granting the more lenient or dangerous permissions to the &#x201c;unsandboxed&#x201d; language is conventional, and reflected in the way PostgreSQL is more restrictive about what roles can create functions in that language.</p>
<p>The <a class="externalLink" href="https://docs.oracle.com/en/java/javase/14/security/permissions-jdk1.html#GUID-1E8E213A-D7F2-49F1-A2F0-EFB3397A8C95">permissions known to the JDK</a> are plentiful and fine-grained. New permissions can also be defined and required in custom code, and selectively granted in the policy like any other permission.</p>
<p>The <code>PLPrincipal</code> indicating sandboxed/unsandboxed is only one of the conditions that can be referred to in a policy to control the permissions granted. Others are described below.</p></section><section>
<h2><a name="Sources_of_Java_policy"></a>Sources of Java policy</h2>
<p>Java&#x2019;s standard <code>Policy</code> implementation will read from a sequence of policy files specified as URLs. The first is normally part of the Java installation, supplying permission grants necessary for trouble-free operation of the JVM itself, and a second will be read, if present, from a user&#x2019;s home directory.</p>
<p>PL/Java, by default, uses the first Java-supplied URL, for the policy file installed with Java, followed by the file <code>pljava.policy</code> in the directory reported by <code>pg_config --sysconfdir</code>. A default version of that file is installed with PL/Java.</p>
<p>The <code>pljava.policy</code> file, by default, is used <i>instead of</i> any <code>.java.policy</code> file in the OS user&#x2019;s home directory that Java would normally load. There probably is no such file in the <code>postgres</code> user&#x2019;s home directory, and if for any reason there is one, it probably is not tailored to PL/Java.</p>
<p>The <a href="variables.html">configuration variable</a> <code>pljava.policy_urls</code> can be used to name different, or additional, policy files.</p>
<p>Permission grants are cumulative in Java&#x2019;s standard <code>Policy</code> implementation: there is no policy syntax to <i>deny</i> a permission if it is conveyed by some other applicable grant in any of the files on the <code>policy_urls</code> list. If an application must restrict a permission that is granted unconditionally in the Java-supplied policy file, for example, the typical approach would be to copy that file, remove the grant of that permission, and alter <code>pljava.policy_urls</code> to read the modified file in place of the original.</p></section><section>
<h2><a name="Conditional_and_unconditional_permission_grants"></a>Conditional and unconditional permission grants</h2>
<p>A <code>grant</code> in a policy can be unconditional, for example:</p>

<div class="source">
<div class="source">
<pre>grant {
    permission java.util.PropertyPermission
        &quot;sqlj.defaultconnection&quot;, &quot;read&quot;;
};
</pre></div></div>

<p>That grant (which is included in the default <code>pljava.policy</code>) allows any Java code to read that property.</p>
<p>Conditional grants to <code>PLPrincipal$Sandboxed</code> and <code>PLPrincipal$Unsandboxed</code> were shown above.</p>
<p>It is also possible to condition a grant on the codebase (represented as a URL) of the code being executed. If the <code>SQLJ.INSTALL_JAR</code> function is used to install PL/Java&#x2019;s examples jar under the name <code>examples</code>, this grant will allow the JSR-310 test example to work:</p>

<div class="source">
<div class="source">
<pre>grant codebase &quot;sqlj:examples&quot; {
    permission java.util.PropertyPermission &quot;user.timezone&quot;, &quot;write&quot;;
};
</pre></div></div>

<p>The <code>sqlj</code> URL scheme is (trivially, and otherwise nonfunctionally) defined within PL/Java to allow forming a codebase URL from the name of an installed jar.</p><section>
<h3><a name="Grant_conditions_currently_unsupported"></a>Grant conditions currently unsupported</h3>
<p>A reader familiar with Java security policy may consider granting permissions based on the signer identity of a cryptographically signed jar, or on a <code>Principal</code> representing the PostgreSQL role executing the current function. In this version of PL/Java, such grants are not yet supported.</p>
<p>While it is not yet possible to grant permissions based on a principal representing the PostgreSQL session user or role, it is possible for a superuser, with <code>ALTER ROLE ... SET</code>, to set user-specific values of <code>pljava.policy_urls</code> that will load different, or additional, policy files. While that will only reflect the connected user at the start of the session and not any role changes during the session, it may be enough for some uses.</p></section><section>
<h3><a name="PLPrincipal_with_a_language_name"></a><code>PLPrincipal</code> with a language name</h3>
<p>The grants for sandboxed/unsandboxed shown above have a <code>*</code> wildcard after the principal class name. It is possible to replace the wildcard with the name of the language (as used in SQL with <code>CREATE LANGUAGE</code> and <code>CREATE FUNCTION</code>) in which a function is declared.</p>
<p>A basic installation of PL/Java creates just two named languages, <code>java</code> and <code>javaU</code>, declared as <code>TRUSTED</code>/sandboxed and untrusted/unsandboxed, respectively. In such an installation, these grants would be effectively equivalent to those shown earlier:</p>

<div class="source">
<div class="source">
<pre>grant principal org.postgresql.pljava.PLPrincipal$Sandboxed &quot;java&quot; {
};

grant principal org.postgresql.pljava.PLPrincipal$Unsandboxed &quot;javaU&quot; {
    permission java.io.FilePermission
        &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,readlink,write,delete&quot;;
};
</pre></div></div>

<p>However, it is possible to use <code>CREATE LANGUAGE</code> to create any number of named languages that share PL/Java&#x2019;s handler entries and can be used to declare PL/Java functions. For example, suppose <code>CREATE TRUSTED LANGUAGE</code> is used to create another language entry with the name <code>java_tzset</code> and this grant is included in the policy:</p>

<div class="source">
<div class="source">
<pre>grant principal org.postgresql.pljava.PLPrincipal$Sandboxed &quot;java_tzset&quot; {
    permission java.util.PropertyPermission &quot;user.timezone&quot;, &quot;write&quot;;
};
</pre></div></div>

<p>If the JSR-310 test example in PL/Java&#x2019;s examples jar is declared with <code>LANGUAGE java_tzset</code> rather than <code>LANGUAGE java</code> (as, in fact, it is), it will be able to set the time zone and succeed.</p>
<p>The <a href="../pljava/apidocs/org.postgresql.pljava.internal/org/postgresql/pljava/management/Commands.html#alias_java_language"><code>SQLJ.ALIAS_JAVA_LANGUAGE</code></a> function can be used to create such aliases conveniently.</p>
<p>When grants to specific named languages and grants with the wildcard are present, code will have all of the permissions granted to the specific language by name, in addition to all permissions that appear in grants to the language class (<code>PLPrincipal$Sandboxed</code> or <code>PLPrincipal$Unsandboxed</code>, whichever applies) with a wildcard name.</p>
<p>A grant is silently ignored unless the class and the name both match. If the <code>java_tzset</code> language were declared as above but a grant entry used the right name but the <code>PLPrincipal$Unsandboxed</code> class by mistake, that grant would be silently ignored.</p></section><section>
<h3><a name="Grants_to_a_codebase_compared_with_grants_to_a_principal"></a>Grants to a codebase compared with grants to a principal</h3>
<p>Whenever a Java operation requires a permission check, it could be on a call stack several levels deep, perhaps involving code from more than one codebase (or, more generally, &#x201c;protection domain&#x201d;). The Java rule is that the needed permission must be in effect, one way or another, for every protection domain on the call stack at the point where the permission is needed. In other words, the available permissions are the <i>intersection</i>, over all domains on the stack, of the permissions in effect for each domain. The rationale is that the proposed action must not only be something the currently executing method is allowed to do; there is a calling method causing this method to do it, so it must also be something the caller is allowed to do, and so on up the stack. (For one crucial exception to this rule, see <a class="externalLink" href="https://docs.oracle.com/en/java/javase/14/security/java-se-platform-security-architecture.html#GUID-E8898CB5-65BB-4D1A-A574-8F7112FC353F">handling privileges</a>.)</p>
<p>Permissions granted to a <code>Principal</code> are not so tightly bound to what specific code is executing; the same code may execute at different times on behalf of more than one principal. A principal often represents a user or role for whom the code is executing, though role principals are not implemented in this PL/Java release. The sandboxed/unsandboxed function distinction is represented as a kind of <code>Principal</code> because it, too, is a property of the thread of execution, from its entry at the SQL-declared function entry point and through any number of protection domains the thread may traverse. Any permissions granted by principal may be thought of as combined with any codebase-specific permissions in every domain present on the stack.</p></section><section>
<h3><a name="Entry_points_other_than_SQL-declared_functions"></a>Entry points other than SQL-declared functions</h3>
<p>Not every entry into PL/Java is through an SQL-declared function with an associated language name or sandboxed/unsandboxed property. For those that are not, permission decisions are based on an &#x201c;access control context&#x201d; (essentially, the in-effect <code>Principal</code>s and initial protection domains) constructed as described here.</p><section>
<h4><a name="Set-returning_functions"></a>Set-returning functions</h4>
<p>While a set-returning function <i>is</i> declared as an SQL function, the initial call is followed by repeated calls to the returned iterator or ResultSet provider or handle, and a final call to close the provider or handle. The access control context constructed for the initial call is saved, and reused while iterating and closing.</p></section><section>
<h4><a name="Savepoint_and_transaction_listeners"></a>Savepoint and transaction listeners</h4>
<p>Java code may register listeners for callbacks at lifecycle stages of savepoints or transactions. Each callback will execute in the access control context of the code that registered it, except that PL/Java&#x2019;s own domain will also be represented on the stack. Because effective permissions are an intersection over all domains on the stack, if any permission has been granted to the callback&#x2019;s codebase that is not also granted to PL/Java&#x2019;s own code, the callback code will be unable to exercise that permission except within a <a class="externalLink" href="https://docs.oracle.com/en/java/javase/14/security/java-se-platform-security-architecture.html#GUID-E8898CB5-65BB-4D1A-A574-8F7112FC353F"><code>doPrivileged</code></a> block.</p></section><section>
<h4><a name="Mapped_UDT_readSQL.2FwriteSQL_methods"></a>Mapped UDT <code>readSQL</code>/<code>writeSQL</code> methods</h4>
<p>When a Java user-defined type is defined without fully integrating it into PostgreSQL&#x2019;s type system as a <code>BaseUDT</code>, its <code>readSQL</code> and <code>writeSQL</code> methods will not have corresponding SQL function declarations, but will be called directly as PL/Java converts values between PostgreSQL and Java form. Those calls will be made without any <code>PLPrincipal</code>, sandboxed or unsandboxed, so they will execute with only the permissions granted to their codebase or unconditionally.</p>
<p>The conversion functions for a <code>BaseUDT</code> do have SQL function declarations, and will execute in a context constructed based on the declaration in the usual way.</p></section></section><section>
<h3><a name="SQL-declared_functions_not_in_PL.2FJava-managed_jars"></a>SQL-declared functions not in PL/Java-managed jars</h3>
<p>It is possible to issue an SQL <code>CREATE FUNCTION</code> naming a method from a codebase that is not a PL/Java-managed <code>sqlj:</code> jar, such as a jar on the filesystem module path, or a method of the Java runtime itself. For example, many how-to articles can be found on the web that demonstrate a successful PL/Java installation by declaring an SQL function that directly calls <code>java.lang.System.getProperty</code>.</p>
<p>Such declarations are allowed, but will execute as if called from a protection domain with the same <code>Principal</code>s, if any, that PL/Java would normally supply, and no other permissions but those the policy grants unconditionally.</p>
<p><i>Note: many of the how-to articles that can be found on the web happen to demonstrate their <code>System.getProperty</code>-calling example functions on some property that isn&#x2019;t readable under Java&#x2019;s default policy. Those examples should be changed to use a property that is normally readable, such as <code>java.version</code> or <code>org.postgresql.pljava.version</code>.</i></p></section><section>
<h3><a name="Class_static_initializers"></a>Class static initializers</h3>
<p>If a class contains several methods that would be given different access control contexts (declared with different <code>trust</code> or <code>language</code> attributes, say), the permissions available when the class initializer runs will be those of whichever function is called first in a given session. Therefore, when putting actions that require permissions into a class&#x2019;s static initializer, those actions should require only the common subset of permissions that the initializer could be run with no matter which function is called or declared first. Actions that require other specific permissions could be deferred until the first call of a function known to be granted those permissions.</p>
<p>Such actions can be left in the static initializer if a function granted the needed permissions is known to always be the first one that the application will call in any given session.</p></section></section><section>
<h2><a name="Troubleshooting"></a>Troubleshooting</h2>
<p>When in doubt what permissions may need to be granted in <code>pljava.policy</code> to run some existing PL/Java code, these techniques may be helpful.</p><section>
<h3><a name="Running_PL.2FJava_with_a_.E2.80.98trial.E2.80.99_policy"></a>Running PL/Java with a &#x2018;trial&#x2019; policy</h3>
<p>To simplify the job of finding the permissions needed by some existing code, it is possible to run PL/Java at first with a &#x2018;trial&#x2019; policy, allowing code to run while logging permissions that <code>pljava.policy</code> has not granted. The log entries have a condensed format meant to be convenient for this use. Trial policy configuration is described <a href="trial.html">here</a>.</p></section><section>
<h3><a name="Using_policy_debug_features_provided_by_Java"></a>Using policy debug features provided by Java</h3>
<p>Java itself offers a number of debugging switches to reveal details of permission decisions. It may be useful to add <code>-Djava.security.debug=access</code> in the setting of <code>pljava.vmoptions</code>, and observe the messages on the PostgreSQL backend&#x2019;s standard error (which should be included in the log file, if <code>logging_collector</code> is <code>on</code>). It is not necessary to change the <code>pljava.vmoptions</code> setting cluster-wide, such as in <code>postgresql.conf</code>; it can be set in a single session for troubleshooting purposes.</p>
<p>Other options for <code>java.security.debug</code> can be found in <a class="externalLink" href="https://docs.oracle.com/en/java/javase/14/security/troubleshooting-security.html">Troubleshooting Security</a>. Some can be used to filter the logging down to requests for specific permissions or from a specific codebase.</p>
<p>The log output produced by Java&#x2019;s debug options can be voluminous compared to the condensed output of PL/Java&#x2019;s trial policy.</p></section></section><section>
<h2><a name="Forward_compatibility"></a>Forward compatibility</h2>
<p>The current implementation makes use of the Java classes <code>Subject</code> and <code>SubjectDomainCombiner</code> in the <code>javax.security.auth</code> package. That should be regarded as an implementation detail; it may change in a future release, so relying on it is not recommended.</p>
<p>The developers of Java have elected to phase out important language features used by PL/Java to enforce policy. The changes will come in releases after Java 17. For migration planning, Java versions up to and including 17 remain fully usable with this version of PL/Java, and Java 17 is positioned as a long-term support release. For details on how PL/Java will adapt, please bookmark <a class="externalLink" href="https://github.com/tada/pljava/wiki/JEP-411">the JEP 411 topic</a> on the PL/Java wiki.</p></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2003&#x2013;2023<a href="http://tada.se/eng/">Tada AB</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
