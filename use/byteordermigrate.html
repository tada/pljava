<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/use/byteordermigrate.md.vm at 2024-10-19

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>PostgreSQL PL/Java &#x2013; Migrating base-UDT data byte order without a dump/reload</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean"><img src="../images/pljava_logo.jpg"  alt="PL/Java logo combining the PostgreSQL elephant and a Java bean"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2024-10-19</span>
           | <span id="projectVersion">Version: 1.6.8</span>
      </div>
      <div class="xright"><a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a> |
<a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a> |
<a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a> |
<a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Usage</h5>
    <ul>
     <li class="none"><a href="../build/build.html" title="Building PL/Java">Building PL/Java</a></li>
     <li class="none"><a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a></li>
     <li class="none"><a href="../install/upgrade.html" title="Upgrading">Upgrading</a></li>
     <li class="none"><a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a></li>
     <li class="none"><a href="../use/use.html" title="User guide">User guide</a></li>
     <li class="none"><a href="../develop/develop.html" title="Developer notes">Developer notes</a></li>
    </ul>
       <h5>Release Information</h5>
    <ul>
     <li class="none"><a href="../releasenotes.html" title="Release notes">Release notes</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a></li>
     <li class="none"><a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a></li>
     <li class="none"><a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a></li>
     <li class="none"><a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a></li>
     <li class="none"><a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a></li>
     <li class="none"><a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a></li>
     <li class="none"><a href="../pljava-pgxs/index.html" title="PL/Java PGXS">PL/Java PGXS</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="../project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>Migrating base-UDT data byte order without a dump/reload</h1>
<p>Suppose a database has used PL/Java-defined base types in the past, has data
stored in columns of those types, and an upgrade is planned to a future PL/Java
release with a changed default byte order for base types. For example, consider
this table with a column of type <code>javatest.complex</code> (this type is <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/ComplexScalar.java">one of the
supplied examples</a>).</p>

<div class="source">
<pre><code>postgres=# \d complexcircle
     Table &quot;public.complexcircle&quot;
 Column |       Type       | Modifiers
--------+------------------+-----------
 k      | integer          |
 z      | javatest.complex |

postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</code></pre></div>
<p>The table holds eight equally spaced points around a circle in the
complex plane.</p>
<p>Older versions of PL/Java always stored such data with big-endian
byte order. PL/Java 1.5.0 allows byte order to be configured, <i>but the
default for PL/Java-defined base types remains big-endian</i>. In a future
release, the default will be changed to <code>native</code>, that is, whatever
byte order the underlying hardware uses. Intel-based hardware, for example,
is little-endian, and such a change would cause the stored data to be
read incorrectly.</p>
<p>In PL/Java 1.5.0, by default, the legacy table will still be handled
correctly. The control of byte order is by four Java system properties
named <code>org.postgresql.pljava.udt.byteorder.$kind.$dir</code> where <code>$kind</code>
is <code>scalar</code> or <code>mirror</code> and <code>$dir</code> is the conversion direction, <code>p2j</code>
for data conversions from PostgreSQL to Java or <code>j2p</code> for the reverse.
Loading a PL/Java 1.5.0 without changing the default settings, a quick
query of these properties will confirm what they are:</p>

<div class="source">
<pre><code>postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | big_endian
 scalar | j2p | big_endian
(4 rows)
</code></pre></div>
<p>Because scalar (base) types are still using the old, big-endian layout,
a <code>SELECT</code> from the legacy table should succeed, and it does:</p>

<div class="source">
<pre><code>postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</code></pre></div>
<p>But what happens after using <code>\c</code> to get a new session, and <code>SET pljava.vmoptions</code> to change the byte order?</p>

<div class="source">
<pre><code>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar=native';
SET
postgres=#
</code></pre></div>
<p>Here you can see that a shortcut is possible, to set both the
<code>p2j</code> and <code>j2p</code> properties by leaving the direction off. It is even
possible to leave off the kind and direction, and set both conversion
directions for both <code>scalar</code> and <code>mirror</code> types, by setting only one
property, <code>org.postgresql.pljava.udt.byteorder</code>. <i>This works only at
initialization time; after the Java VM is running, these shorter-named
properties do not exist, and setting them has no effect.</i></p>
<p>After setting <code>pljava.vmoptions</code> as above, querying the properties again
should show them set accordingly, and then another query shows how that
legacy table looks:</p>

<div class="source">
<pre><code>postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | native
 scalar | j2p | native
(4 rows)
postgres=# SELECT * FROM complexcircle;
 k |                         z
---+---------------------------------------------------
 0 | (3.03865E-319,0.0)
 1 | (3.526206619982328E171,2.2885481907327986E191)
 2 | (-1.0377513410652091E170,-1.0377513410652091E170)
 3 | (2.2885481907327986E191,3.526206619982328E171)
 4 | (0.0,3.03865E-319)
 5 | (2.288548190732839E191,3.526206619982328E171)
 6 | (-1.0377513410652263E170,-1.0377513410652091E170)
 7 | (3.526206619982383E171,2.2885481907327986E191)
(8 rows)
</code></pre></div>
<p>Now the table seems to have totally bogus values in the <code>z</code> column.
<i>Note: as base types go, <code>javatest.complex</code> is quite simple, and reading
it with the wrong byte order simply produces bogus values. For other
Java-defined base types, other symptoms could result, such as exceptions
during a query.</i></p><section>
<h2><a name="Migrating_legacy_data_with_a_dump.2Freload"></a>Migrating legacy data with a dump/reload</h2>
<p>An obvious way to migrate the old data would be to do a (non-binary) dump,
in a session where the byte-order is still the old default of <code>big_endian</code>,
then start a new session with the order set to <code>native</code>, and reload the data.</p></section><section>
<h2><a name="Migrating_data_with_an_UPDATE"></a>Migrating data with an <code>UPDATE</code></h2>
<p>In many cases a simpler option is available, exploiting the fact that the
two directions <code>p2j</code> and <code>j2p</code> can have their byte-order set <i>independently</i>.</p>
<p>You should be thinking that, for most purposes, that would be an outlandish
thing to do. It can cause even the simplest queries to misbehave:</p>

<div class="source">
<pre><code>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar.j2p=native';
SET
postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | big_endian
 scalar | j2p | native
(4 rows)
postgres=# select '(1,2)'::javatest.complex;
         complex
--------------------------
 (3.03865E-319,3.16E-322)
</code></pre></div>
<p>Clearly not the kind of behavior you would want under any normal conditions.
<i>And again, note that for other base types, such a query might not just
produce weird values, but throw errors or otherwise behave erratically.</i></p>
<p>And yet, for the <i>one special purpose</i> this page is about, having <code>p2j</code> and
<code>j2p</code> set differently is exactly the trick. Let's start another clean session:</p>

<div class="source">
<pre><code>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder.scalar.p2j=big_endian '
   '-Dorg.postgresql.pljava.udt.byteorder.scalar.j2p=native';
SET
postgres=#
</code></pre></div>
<p>A quick select of a value from the column to be updated should show that
it is still read correctly:</p>

<div class="source">
<pre><code>postgres=# SELECT z FROM complexcircle LIMIT 1;
     z
-----------
 (1.0,0.0)
</code></pre></div>
<p>Good, that is one of the expected, correct values. Now, what will happen with
a simple command like:</p>

<div class="source">
<pre><code>postgres=# UPDATE complexcircle SET z = z; -- PostgreSQL is too smart!
UPDATE 8
postgres=# SELECT z FROM complexcircle LIMIT 1;
     z
-----------
 (1.0,0.0)
</code></pre></div>
<p>No joy: the values still look <i>good</i> after this conversion attempt, which
is of course <i>not good</i>, because it means nothing useful happened. PostgreSQL
looked at <code>SET z = z</code> and realized it didn't require doing anything.</p>
<p>What's needed here is a Java function that will take <i>any object</i> as a parameter
and return the same object. A function, in other words, that really changes
nothing, but PostgreSQL doesn't know that, and will therefore have to convert
each stored value to a Java object (<code>p2j</code>), convert the returned object back
(<code>j2p</code>), and store the updated value.</p>
<p>It turns out that exactly such a function is
<a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/AnyTest.java">already supplied in the examples</a>:</p>

<div class="source">
<pre><code>postgres=# \df javatest.loganyelement
                             List of functions
  Schema  |     Name      | Result data type | Argument data types |  Type
----------+---------------+------------------+---------------------+--------
 javatest | loganyelement | anyelement       | anyelement          | normal
(1 row)

postgres=# UPDATE complexcircle SET z = javatest.loganyelement(z);
UPDATE 8
postgres=# SELECT z FROM complexcircle LIMIT 1;
         z
--------------------
 (3.03865E-319,0.0)
(1 row)
</code></pre></div>
<p>Encouragingly, the value now looks <i>bad</i>, which for this purpose is <i>good</i>.
How does it look in another clean session, with all byte order properties
set to <code>native</code>?</p>

<div class="source">
<pre><code>postgres=# \c
You are now connected to database &quot;postgres&quot;
postgres=# SET pljava.vmoptions
TO '-Dorg.postgresql.pljava.udt.byteorder=native';
SET
postgres=# SELECT kind, dir, javatest.java_getsystemproperty(
  format('org.postgresql.pljava.udt.byteorder.%s.%s', kind, dir))
  FROM
    (VALUES ('scalar'), ('mirror')) AS kinds(kind),
    (VALUES ('p2j'), ('j2p')) AS directions(dir)
  ORDER BY kind;
  kind  | dir | java_getsystemproperty
--------+-----+------------------------
 mirror | p2j | native
 mirror | j2p | native
 scalar | p2j | native
 scalar | j2p | native
(4 rows)

postgres=# SELECT * FROM complexcircle;
 k |                  z
---+--------------------------------------
 0 | (1.0,0.0)
 1 | (0.92387953251129,0.38268343236509)
 2 | (0.70710678118655,0.70710678118655)
 3 | (0.38268343236509,0.92387953251129)
 4 | (0.0,1.0)
 5 | (-0.38268343236509,0.92387953251129)
 6 | (-0.70710678118655,0.70710678118655)
 7 | (-0.92387953251129,0.38268343236509)
(8 rows)
</code></pre></div>
<p>Mission accomplished. After using that procedure to update all columns of
legacy data in PL/Java-defined base types, all that remains is to make sure
PL/Java will use the new byte order from that point forward. If the migration
is done at the time of upgrading to a PL/Java version that makes the new
order default, the job is done; if migrating in advance, a persistently-saved
<code>pljava.vmoptions</code> (in any of the usual ways, such as <code>ALTER DATABASE ... SET</code>,
<code>ALTER SYSTEM</code>, or editing <code>postgresql.conf</code>) will need to include the new
byte order setting, which can be taken out after a later upgrade to a PL/Java
version that makes the new setting the default.</p></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2003&#x2013;2024<a href="http://tada.se/eng/">Tada AB</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
