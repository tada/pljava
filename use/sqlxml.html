<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/markdown/use/sqlxml.md at 2024-10-19

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>PostgreSQL PL/Java &#x2013; Working with XML</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean"><img src="../images/pljava_logo.jpg"  alt="PL/Java logo combining the PostgreSQL elephant and a Java bean"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2024-10-19</span>
           | <span id="projectVersion">Version: 1.6.8</span>
      </div>
      <div class="xright"><a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a> |
<a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a> |
<a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a> |
<a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Usage</h5>
    <ul>
     <li class="none"><a href="../build/build.html" title="Building PL/Java">Building PL/Java</a></li>
     <li class="none"><a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a></li>
     <li class="none"><a href="../install/upgrade.html" title="Upgrading">Upgrading</a></li>
     <li class="none"><a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a></li>
     <li class="none"><a href="../use/use.html" title="User guide">User guide</a></li>
     <li class="none"><a href="../develop/develop.html" title="Developer notes">Developer notes</a></li>
    </ul>
       <h5>Release Information</h5>
    <ul>
     <li class="none"><a href="../releasenotes.html" title="Release notes">Release notes</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a></li>
     <li class="none"><a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a></li>
     <li class="none"><a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a></li>
     <li class="none"><a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a></li>
     <li class="none"><a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a></li>
     <li class="none"><a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a></li>
     <li class="none"><a href="../pljava-pgxs/index.html" title="PL/Java PGXS">PL/Java PGXS</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="../project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>Working with XML</h1><section>
<h2><a name="In_PL.2FJava_before_1.5.1"></a>In PL/Java before 1.5.1</h2>
<p>PL/Java functions before 1.5.1 have been able to access a value of XML type as
a <code>String</code> object. That has been workable, but an extra burden if porting code
that used the JDBC 4.0 <code>java.sql.SQLXML</code> API, and with notable shortcomings.</p><section>
<h3><a name="Shortcomings"></a>Shortcomings</h3><section>
<h4><a name="Character_set_encoding"></a>Character set encoding</h4>
<p>PostgreSQL stores XML values serialized according to <code>server_encoding</code>, and
depending on that setting, conversion to a Java <code>String</code> can involve
transcoding.</p>
<p>XML has rules to handle characters that may be representable in one encoding
but not another, but the <code>String</code> conversion is unaware of them, and may fail
to produce a transcoding that represents the same XML value.</p></section><section>
<h4><a name="Memory_footprint"></a>Memory footprint</h4>
<p>While a database design using XML may be such that each XML datum is
individually very small, it is also easy to store&#x2014;or generate in
queries&#x2014;large XML values. When mapped to a Java <code>String</code>, such an XML value
must have its full, uncompressed, character-serialized size allocated
on the Java heap and be copied there from native memory, before the Java
code even begins to make use of it. Even in cases where the Java processing to
be done could be organized to stream through parse events in constant-bounded
memory, the <code>String</code> representation forces the entire XML value to occupy Java
memory at once. Any tuning of PL/Java's heap size allowance could have to
consider a worst-case estimate of that size, or risk failures at run time.</p></section></section></section><section>
<h2><a name="The_JDBC_4.0_java.sql.SQLXML_API"></a>The JDBC 4.0 <code>java.sql.SQLXML</code> API</h2>
<p>PL/Java 1.5.1 adds support for this API. A Java parameter or return type in a
a PL/Java function can be declared to be <code>SQLXML</code>, and such objects can be
retrieved from <code>ResultSet</code> and <code>SQLInput</code> objects, and used as
<code>PreparedStatement</code> parameters or in <code>SQLOutput</code> and updatable <code>ResultSet</code>
objects.</p><section>
<h3><a name="Reading_a_PostgreSQL_XML_value_as_a_readable_SQLXML_object"></a>Reading a PostgreSQL XML value as a <i>readable</i> <code>SQLXML</code> object</h3>
<p>An <code>SQLXML</code> instance can have the &#x201c;conceptual states&#x201d; <i>readable</i> and <i>not
readable</i>, <i>writable</i> and <i>not writable</i>. In PL/Java, an instance passed in as a
parameter to a function, or retrieved from a <code>ResultSet</code>, is <i>readable</i> and <i>not
writable</i>, and can be used as input to Java processing using any of the
following methods:</p>
<dl>

<dt><code>getBinaryStream()</code></dt>
<dd>Obtain an <code>InputStream</code> with the raw, byte-stream-serialized XML, which will
have to be passed to an XML parser. The parser will have to determine the
encoding used from the declaration at the start of the stream, or assume
UTF-8 if there is none, as the standard provides.</dd>
<dt><code>getCharacterStream()</code></dt>
<dd>Like <code>getBinaryStream</code> but as a stream of Java characters, with the underlying
encoding already decoded. May be convenient for use with parsing code that
isn't able to recognize and honor the encoding declaration, but any standard
XML parser would work as well from <code>getBinaryStream</code>, which should be
preferred when possible. A parser working from the binary stream is able to
handle transcoding, if needed, in an XML-aware way. With this method, any
needed transcoding is done without XML-awareness to produce the character
stream.</dd>
<dt><code>getString()</code></dt>
<dd>Obtain the entire serialized XML value decoded as a Java <code>String</code>. Has the
same memory footprint and encoding implications discussed for the legacy
conversion to <code>String</code>, but may be convenient for some purposes or for
values known to be small.</dd>
<dt><code>getSource(javax.xml.transform.stream.StreamSource.class)</code></dt>
<dd>Equivalent to one of the first two methods, but with the stream wrapped in
a <code>Source</code> object, directly usable with Java XML transformation APIs.</dd>
<dt><code>getSource(javax.xml.transform.sax.SAXSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object that presents the XML in parsed form via the SAX API,
where the caller can register callback methods for XML constructs of
interest, and then have Java stream through the XML value, calling those
methods.</dd>
<dt><code>getSource(javax.xml.transform.sax.StAXSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object that presents the XML in parsed form via the StAX
API, where the value can be streamed through by calling StAX pull methods
to get one XML construct at a time. Java code written to this API can more
clearly reflect the expected structure of the XML document, compared to
code written in the callback style for SAX.</dd>
<dt><code>getSource(javax.xml.transform.sax.DOMSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object presenting the XML fully parsed as a navigable,
in-memory DOM tree.</dd>
<dt><code>getSource(null)</code></dt>
<dd>Obtain a <code>Source</code> object of a type chosen by the implementation. Useful when
the <code>Source</code> object will be passed to a standard Java transformation API,
which can handle any of the above forms, letting the <code>SQLXML</code> implementation
choose one that it implements efficiently.</dd>
</dl>
<p>Exactly one of these methods can be called exactly once on a <i>readable</i> <code>SQLXML</code>
object, which is thereafter <i>not readable</i>. (The <i>not readable</i> state prevents
a second call to any of the getter methods; it does not, of course, prevent
reading the XML content through the one stream, <code>String</code>, or <code>Source</code> obtained
from the getter method that was just called.)</p>
<p>Except in the <code>String</code> or DOM form, which bring the entire XML value into Java
memory at once, the XML content is streamed directly from native PostgreSQL
memory as Java code reads it, never accumulating in the Java heap unless that
is what the application code does with it. Java heap sizing, therefore, can
be based on just what the application Java code will do with the data.</p>
<p>The most convenient API to use in an application will often be SAX or StAX,
in which the code can operate at the level of already-parsed, natural XML
constructs. Code designed to work with a navigable DOM tree can easily obtain
that form (but it should be understood that DOM will pull the entire content
into Java memory at once, in a memory-hungry form that can easily be twenty
times the size of the serialized value).</p><section>
<h4><a name="Obtaining_a_readable_SQLXML_object"></a>Obtaining a <i>readable</i> <code>SQLXML</code> object</h4>
<p>To obtain a <i>readable</i> instance, declare <code>java.sql.SQLXML</code> as the type of a
function parameter where PostgreSQL will pass an XML argument, or use the
<code>getSQLXML</code> or <code>getObject(..., SQLXML.class)</code> methods on a <code>ResultSet</code>, or the
<code>readSQLXML</code> or <code>readObject(SQLXML.class)</code> methods on <code>SQLInput</code>. A fully
JDBC-4.0 compliant driver would also return <code>SQLXML</code> instances from the
non-specific <code>getObject</code> and <code>readObject</code> methods, but in PL/Java, those have
historically returned <code>String</code>. Because 1.5.1 is not a major release, their
behavior has not changed, and the more-specific methods must be used to obtain
<code>SQLXML</code> instances.</p></section></section><section>
<h3><a name="Creating.2Freturning_a_PostgreSQL_XML_value_with_a_writable_SQLXML_object"></a>Creating/returning a PostgreSQL XML value with a <i>writable</i> <code>SQLXML</code> object</h3>
<p>PL/Java will supply an empty <code>SQLXML</code> instance that is <i>writable</i> and <i>not
readable</i> via the <code>Connection</code> method <code>createSQLXML()</code>. It can be used as an
output destination for any of several Java XML APIs, through a selection of
<code>set...</code> methods exactly mirroring the available <code>get...</code> methods described
above.</p>
<p><i>The API is unusual: except for <code>setString</code>, which takes a <code>String</code> parameter
and returns <code>void</code> as a typical &#x201c;setter&#x201d; method would, the other setter methods
are used for the object they return&#x2014;an <code>OutputStream</code>, <code>Writer</code>, or
<code>Result</code>&#x2014;which the calling code should then use to add content to the XML
value.</i></p>
<p>Exactly one setter method can be called exactly once on a <i>writable</i> <code>SQLXML</code>
object, which is thereafter <i>not writable</i>. (The <i>not writable</i> state prevents
a second call to any setter method; XML content must still be written via the
stream or <code>Result</code> obtained from the one setter that was just called, except
in the case of <code>setString</code>, which populates the value at once.) Content being
written to the <code>SQLXML</code> object is accumulated in PostgreSQL native memory,
not the Java heap.</p>
<p>A <code>SQLXML</code> object, once it has been fully written and closed, can be
returned from a Java function, passed as a <code>PreparedStatement</code> parameter to a
nested query, or stored into writable <code>ResultSet</code>s used for composite function
or trigger results. It can be used exactly once in any of those ways, which
transfer its ownership back to PostgreSQL, leaving it inaccessible from Java.</p><section>
<h4><a name="When_a_writable_SQLXML_object_is_considered_closed"></a>When a <i>writable</i> <code>SQLXML</code> object is considered closed</h4>
<p>A <i>writable</i> <code>SQLXML</code> object cannot be presented to PostgreSQL before it is
closed to confirm that writing is complete. (One written by <code>setString</code> is
considered written, closed, and ready to use immediately.)</p>
<p>When it is written using a stream obtained from <code>setBinaryStream</code>,
<code>setCharacterStream</code>, or
<code>setResult(javax.xml.transform.stream.StreamResult.class)</code>, it
is considered closed when the stream's <code>close</code> method is called.
This will typically <i>not</i> be done by a Java <code>Transformer</code> with the stream
as its result, and so should be explicitly called after such a transformation
completes.</p>
<p>When written using a <code>SAXResult</code>, it is considered closed when the
<code>ContentHandler</code>'s <code>endDocument</code> method is called, and when written using a
<code>StAXResult</code>, it is considered closed when the <code>XMLStreamWriter</code>'s
<code>writeEndDocument</code> method is called. When one of these flavors of <code>Result</code> is
used with a Java <code>Transformer</code>, these methods will have been called in the
normal course of the transformation, so nothing special needs to be done after
the transformation completes.</p>
<p>What it means to <code>close</code> a <code>DOMResult</code> is murkier. The application code must
call the <code>DOMResult</code>'s <code>setNode</code> method, passing what will be the root node of
the result document. This can be done before or after (or while) child nodes and
content are added to that node. However, to avoid undefined behavior,
application code must make no further modification to that DOM tree after the
<code>SQLXML</code> object has been presented to PostgreSQL (whether via a
<code>PreparedStatement</code> <code>set</code> method, <code>ResultSet</code> <code>update</code> method,
<code>SQLOutput</code> <code>write</code> method, or returned as the function result).</p></section><section>
<h4><a name="Using_a_Result_object_as_a_Transformer_result"></a>Using a <code>Result</code> object as a <code>Transformer</code> result</h4>
<p>Classes that extend <code>javax.xml.transform.Transformer</code> will generally accept
any flavor of <code>Result</code> object and select the right API to write the
transformation result to it. There is often no need to care which <code>Result</code>
flavor to provide, so it is common to call <code>setResult(null)</code> to let the
<code>SQLXML</code> implementation itself choose a flavor based on implementation-specific
efficiency considerations.</p>
<p>In the case of a <code>DOMResult</code>, if the <code>Result</code> object is simply passed to a
<code>Transformer</code> without calling <code>setNode</code> first, the <code>Transformer</code> itself will
put an empty <code>Document</code> node there, which is then populated with the
transformation results.</p>
<p>A <code>Document</code> node, however, enforces conformance to the strict rules of
<code>XML(DOCUMENT)</code> form (described below). If the content to be written will
conform only to the looser rules of <code>XML(CONTENT)</code> form, application code should
call <code>setNode</code> supplying an empty <code>DocumentFragment</code> node, before passing the
<code>Result</code> object to a <code>Transformer</code>.</p>
<p>The flavor of <code>Result</code> returned by <code>setResult(null)</code> will never
(in PL/Java) be <code>DOMResult</code>.</p></section></section><section>
<h3><a name="Using_an_unread_readable_SQLXML_object_as_a_written_one"></a>Using an unread <i>readable</i> <code>SQLXML</code> object as a written one</h3>
<p>The general rule that only a <i>writable</i> instance (that has been written and
closed) can be used as a function result, or passed into a nested query, admits
one exception, allowing a <i>readable</i> instance that Java code has obtained but
not read. That makes it simple for Java code to obtain an <code>SQLXML</code> instance
passed in as a parameter, or from a query, and use it directly as a result or a
nested-query parameter. Any one instance can be used this way no more than once.</p></section><section>
<h3><a name="XML.28DOCUMENT.29_and_XML.28CONTENT.29"></a><code>XML(DOCUMENT)</code> and <code>XML(CONTENT)</code></h3>
<p>An XML value in SQL can have the type <code>XML(DOCUMENT)</code> or <code>XML(CONTENT)</code> (as
those are defined in the ISO SQL standard, 2006 and later), which PostgreSQL
does not currently treat as distinguishable types. The <code>DOCUMENT</code> form must have
exactly one root element, may have a document-type declaration (DTD), and has
strict limits on where other
constructs (other than comments and processing instructions) can occur. A value
in <code>CONTENT</code> form may have no root element, or more than one element at top
level, and other constructs such as character data outside of a root element
where <code>DOCUMENT</code> form would not allow them.</p><section>
<h4><a name="How_both_forms_are_accommodated_when_reading"></a>How both forms are accommodated when reading</h4>
<p>Java code using a <i>readable</i> <code>SQLXML</code> instance as input should be prepared to
encounter either form (unless it has out-of-band knowledge of which form will be
supplied). If it requests a <code>DOMSource</code>, <code>getNode()</code> will return a <code>Document</code>
node, if the value met all the requirements for <code>DOCUMENT</code>, or a
<code>DocumentFragment</code> node, if it was parsable as <code>CONTENT</code>. Java code requesting a
<code>SAXSource</code> or <code>StAXSource</code> should be prepared to handle a sequence of
constructs that might not be encountered when parsing a strictly conforming
<code>DOCUMENT</code>. Java code that requests an <code>InputStream</code>, <code>Reader</code>, <code>String</code>, or
<code>StreamSource</code> will be on its own to parse the data in whichever form appears.</p><section>
<h5><a name="Effect_on_parsing_of_whitespace"></a>Effect on parsing of whitespace</h5>
<p>In <code>DOCUMENT</code> form, any whitespace outside of the single root element is
considered markup, not character data. When the value is parsable as <code>DOCUMENT</code>,
and read through PL/Java's <code>SAXSource</code> or <code>StAXSource</code>, no whitespace that
occurs outside of the root element will be reported to the application.
PL/Java's <code>DOMSource</code> will present a <code>Document</code> node with no whitespace
text-node children outside of the root element.</p>
<p>If the value parses as <code>CONTENT</code>, PL/Java's <code>DOMSource</code> will present a
<code>DocumentFragment</code> node with all character data, including whitespace,
preserved. The streaming operation of the <code>SAXSource</code> and <code>StAXSource</code> is more
complicated, and lossy for whitespace (only if it occurs outside of any element)
ahead of the first parse event that would not be possible in <code>DOCUMENT</code> form.
All whitespace beyond that point is preserved.</p></section></section><section>
<h4><a name="How_both_forms_are_accommodated_when_writing"></a>How both forms are accommodated when writing</h4>
<p>Java code using a <i>writable</i> SQLXML instance to produce a result may write
either <code>DOCUMENT</code> or <code>CONTENT</code> form. If using <code>DOMResult</code>, it must supply a
<code>DocumentFragment</code> node to produce a <code>CONTENT</code> result, as a <code>Document</code> node will
enforce the <code>DOCUMENT</code> requirements.</p></section></section><section>
<h3><a name="An_SQLXML_object_has_transaction_lifetime"></a>An <code>SQLXML</code> object has transaction lifetime</h3>
<p>The JDBC spec provides that an <code>SQLXML</code> instance is &#x201c;valid for the duration of
the transaction in which it was created.&#x201d; One PL/Java function can hold an
<code>SQLXML</code> instance (in a static or session variable or data structure), and other
PL/Java functions called later in the same transaction can continue reading from
or writing to it. If the transaction has committed or rolled back, those
operations will generate an exception.</p>
<p>Once a <i>writable</i> <code>SQLXML</code> object, or an unread, <i>readable</i> one, has been
presented to PostgreSQL as the result of a PL/Java function or through a
<code>PreparedStatement</code>/<code>ResultSet</code>/<code>SQLOutput</code> setter method, it is no longer
accessible in Java.</p>
<p>During a transaction, resources held by a <code>SQLXML</code> object are reclaimed as soon
as a <i>readable</i> one has been fully read, or a <i>writable</i> one has been presented
to PostgreSQL and PostgreSQL is done with it. If application code holds a
readable <code>SQLXML</code> object that it determines it will not read, or a writable one
it will not present to PostgreSQL, it can call the <code>free</code> method to allow the
resources to be reclaimed sooner than the transaction's end.</p></section><section>
<h3><a name="Lazy_detoasting"></a>Lazy detoasting</h3>
<p>PostgreSQL can represent large XML values in &#x201c;TOASTed&#x201d; form, which may be in
memory but compressed (XML typically compresses to a small fraction of its
serialized size), or may be a small pointer to a location in storage. A
<i>readable</i> <code>SQLXML</code> instance over a TOASTed value will not be detoasted until
Java code actually begins to read it, so the memory footprint of an instance
being held but not yet read is kept low.</p></section><section>
<h3><a name="Validation_of_content"></a>Validation of content</h3>
<p>Some of the methods by which a <i>writable</i> instance can be written are not
XML-specific APIs, but allow arbitrary content to be written (as a <code>String</code>,
<code>Writer</code>, or <code>OutputStream</code>). When written by those methods, type safety is
upheld by verifying that the written content can be successfully reparsed,
accepting either <code>DOCUMENT</code> or <code>CONTENT</code> form.</p>
<p>It remains possible to declare the Java type <code>String</code> for function parameters
and returns of XML type, and to retrieve and supply <code>String</code> for <code>ResultSet</code>
columns and <code>PreparedStatement</code> parameters of XML type. This legacy mapping
from <code>String</code> to XML uses PostgreSQL's <code>xml_in</code> function to verify the form of a
<code>String</code> from Java. That function may reject some valid values if the server
configuration variable <code>xmloption</code> is not first set to <code>DOCUMENT</code> or <code>CONTENT</code>
to match the type of the value.</p><section>
<h4><a name="Validation_against_a_schema"></a>Validation against a schema</h4>
<p>Java's XML APIs support validation using a choice of schema languages;
support for XML Schema 1.0 is included in the Java runtime, and implementations
of others can be placed on the class path.</p>
<p>A <code>schema</code> method is available through the &#x201c;Extended API to configure
XML parsers&#x201d; described below, but will only work on a <code>SAXSource</code> or <code>DOMSource</code>
(or a <code>StreamResult</code>, which uses a SAX parser to validate the stream written).
Other limitations are described under &#x201c;known limitations&#x201d; below.</p>
<p>More flexibly, <code>javax.xml.validation.Validator</code> or
<code>javax.xml.validation.ValidatorHandler</code> can be used in more situations and with
fewer limitations.</p></section></section><section>
<h3><a name="Usable_with_or_without_native_XML_support_in_PostgreSQL"></a>Usable with or without native XML support in PostgreSQL</h3>
<p>In symmetry to using Java <code>String</code> for SQL XML types, PL/Java allows the Java
<code>SQLXML</code> type to be used with PostgreSQL data of type <code>text</code>. This allows full
use of the Java XML APIs even in PostgreSQL instances built without XML support.
All of the <code>SQLXML</code> behaviors described above also apply in this usage.</p>
<p>If a <i>readable</i> <code>SQLXML</code> instance obtained from a <code>text</code> value is directly used
to set or return a value of PostgreSQL's XML type, the XML-ness of the content
is verified.</p></section></section><section>
<h2><a name="Extensions_to_the_java.sql.SQLXML_API"></a>Extensions to the <code>java.sql.SQLXML</code> API</h2><section>
<h3><a name="Extended_API_to_configure_XML_parsers"></a>Extended API to configure XML parsers</h3>
<p>Retrieving or verifying the XML content in an <code>SQLXML</code> object can involve
applying an XML parser. The full XML specification includes features that can
require an XML parser to retrieve external resources or consume unexpected
amounts of memory. The full feature support may be an asset in an environment
where the XML content will always be from a known, trusted source, or a
liability if less is known about the XML content being processed.</p>
<p>The <a class="externalLink" href="https://www.owasp.org/index.php/About_The_Open_Web_Application_Security_Project">Open Web Application Security Project</a> (OWASP) advocates for the
default use of settings that strictly limit the related features of Java XML
parsers, as outlined in a <a class="externalLink" href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java">&#x201c;cheat sheet&#x201d;</a> the organization publishes.</p>
<p>However, the recommended defaults really are severely restrictive (for example,
disabling document-type declarations by default will cause PL/Java's <code>SQLXML</code>
implementation to reject all XML values that contain DTDs). Therefore, there
must be a simple and clear way for code to selectively adjust the settings, or
adopting the strictest settings by default would pose an unacceptable burden to
developers.</p>
<p>The traditional Java way to adjust the XML parser is overwhelmingly fiddly,
involving <code>setFeature</code> or <code>setProperty</code> calls that identify the feature to be
set by passing an arcane URI that might be found in the documentation, or the
<a class="externalLink" href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java">cheat sheet</a>, or cargo-culted from some other code base. In some cases,
the streamlined <code>SQLXML</code> API conceals the steps where adjustments would have
to be applied. With no better way to adjust the parser, it would be an
unrealistic developer burden to adopt the restrictive defaults and expect the
developer to relax them.</p>
<p>Therefore, PL/Java has an extension API documented at the
<a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">org.postgresql.pljava.Adjusting.XML class</a>. With the API, it is possible
to obtain a <code>Source</code> object from an <code>SQLXML</code> instance <code>sqx</code> in either the
standard or extended way shown in this example for a <code>SAXSource</code>:</p>

<div class="source">
<pre><code>SAXSource src = sqx.getSource(SAXSource.class); // OR
SAXSource src = sqx.getSource(Adjusting.XML.SAXSource.class)
                   .allowDTD(true).get();
</code></pre></div>
<p>The first form would obtain a <code>SAXSource</code> configured with the restrictive,
OWASP-recommended defaults, which would reject any content with a DTD. The
second form would obtain a <code>SAXSource</code> configured to allow a DTD in the
content, with other parser features left at the restrictive defaults.</p><section>
<h4><a name="Additional_adjustments_in_recent_Java_versions"></a>Additional adjustments in recent Java versions</h4>
<p>Additional security-related adjustments have appeared in various Java releases,
and are described in the <a class="externalLink" href="https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html">Java API for XML Processing Security Guide</a>.
They include a number of configurable limits on maximum sizes and nesting
depths, and limits to the set of protocols allowable for fetching external
resources. Corresponding methods are provided in <a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">PL/Java's API</a>.
Also see &#x201c;known limitations&#x201d; below.</p></section><section>
<h4><a name="Supplying_a_SAX_or_DOM_EntityResolver_or_Schema"></a>Supplying a SAX or DOM <code>EntityResolver</code> or <code>Schema</code></h4>
<p>Methods are provided to set an <code>EntityResolver</code> that controls how a SAX or DOM
parser resolves references to external entities, or a <code>Schema</code> by which a SAX
or DOM parser can validate content while parsing. Corresponding methods are
supplied in PL/Java's API, but are implemented only when operating on a
<code>SAXSource</code> or <code>DOMSource</code> (or <code>StreamResult</code>, affecting its validation of
the content written).</p>
<p>For StAX, control of resolution is done with a slightly different class,
<code>XMLResolver</code>, which can be set on a StAX parser as an ordinary property;
this can be done with PL/Java's <code>setFirstMatchingProperty</code> method.</p>
<p>A StAX parser cannot have a <code>Schema</code> directly assigned, but can be used
with a <code>javax.xml.validation.Validator</code>.</p>
<p>Complete details can be found <a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">in the API documentation</a>.</p></section><section>
<h4><a name="Using_XML_Catalogs_when_running_on_Java_9_or_later"></a>Using XML Catalogs when running on Java 9 or later</h4>
<p>When running on Java 9 or later, a local XML Catalog can be set up to
efficiently and securely resolve what would otherwise be external resource
references. The registration of a Catalog on a Java 9 or later parser involves
only existing methods for setting features/properties, as described
<a class="externalLink" href="https://docs.oracle.com/javase/9/core/xml-catalog-api1.htm#JSCOR-GUID-51446739-F878-4B70-A36F-47FBBE12A26A">in the Catalog API documentation</a>, and can be done with the
<code>setFirstSupportedFeature</code> and <code>setFirstSupportedProperty</code> methods
in PL/Java's <code>Adjusting</code> API.</p>
<p>When running on Java 22 or later, there is also a fallback catalog that can
satisfy requests for a small number of DTDs that are defined by the Java
platform. The behavior when this fallback resolver cannot satisfy a request
can be configured by setting the <code>jdk.xml.jdkcatalog.resolve</code> property, for
which, again, the <code>setFirstSupportedProperty</code> method can be used.</p></section></section><section>
<h3><a name="Extended_API_to_set_the_content_of_a_PL.2FJava_SQLXML_instance"></a>Extended API to set the content of a PL/Java <code>SQLXML</code> instance</h3>
<p>When a <code>SQLXML</code> instance is returned from a PL/Java function, or passed in to
a PL/Java <code>ResultSet</code> or <code>PreparedStatement</code>, it is used directly if it is an
instance of PL/Java's internal implementation.</p>
<p>However, a PL/Java function might reasonably use another JDBC driver and obtain
a <code>SQLXML</code> instance from a connection to some other database. If such a
&#x2018;foreign&#x2019; <code>SQLXML</code> object is returned from a function, or passed to a PL/Java
<code>ResultSet</code> or <code>PreparedStatement</code>, its content must first be copied to a new
instance created by PL/Java's driver. This happens transparently (but implies
that the &#x2018;foreign&#x2019; instance must be in <i>readable</i> state at the time, and
afterward will not be).</p>
<p>The transparent copy is made by passing <code>null</code> as <code>sourceClass</code> to the foreign
object's <code>getSource</code> method, so the foreign object is in control of the type of
<code>Source</code> it will return. PL/Java will copy from a <code>StreamSource</code>, <code>SAXSource</code>,
<code>StAXSource</code>, or <code>DOMSource</code>. In the case of a <code>StreamSource</code>, an XML parser
will be involved, either to verify that the stream is XML, or to parse and
reserialize it if necessary to adapt its encoding to the server's. The parser
used by default will have the default, restrictive settings.</p>
<p>To allow adjustment of those settings, the copying operation can be invoked
explicitly through the <code>Adjusting.XML.SourceResult</code> class. For example, when
<i>sx</i> is a &#x2018;foreign&#x2019; <code>SQLXML</code> object, the transparent operation</p>

<div class="source">
<pre><code>return sx;
</code></pre></div>
<p>is equivalent to</p>

<div class="source">
<pre><code>return conn.createSQLXML().setResult(Adjusting.XML.SourceResult.class)
           .set(sx.getSource(null)).get().getSQLXML();
</code></pre></div>
<p>where <i>conn</i> is the PL/Java JDBC connection named by
<code>jdbc:default:connection</code>. To adjust the parser settings, as usual, adjusting
methods can be chained after the <code>set</code> and before the <code>get</code>. The explicit form
also allows passing a <code>sourceClass</code> other than <code>null</code> to the foreign object's
<code>getSource</code> method, if there is a reason not to let the foreign object choose
the type of <code>Source</code> to return.</p></section><section>
<h3><a name="SQLXML_views_of_non-XML_data"></a><code>SQLXML</code> views of non-XML data</h3>
<p>There are the beginnings of a feature supporting
<a href="xmlview.html">XML views of non-XML data</a>, so that some data types that are
not XML, but are similarly tree-structured, can be manipulated in Java using
Java's extensive support for XML.</p></section></section><section>
<h2><a name="Known_limitations"></a>Known limitations</h2><section>
<h3><a name="Limitations_of_StAX_support"></a>Limitations of <code>StAX</code> support</h3>
<p>PL/Java's <code>StAXSource</code> supplies an <code>XMLStreamReader</code> that only supports the
expected usage pattern:</p>

<div class="source">
<pre><code>while ( streamReader.hasNext() )
{
  streamReader.next();
  /* methods that query state of the current parse event */
}
</code></pre></div>
<p>It would be unexpected to reorder that pattern so that queries of the current
event occur after <code>hasNext</code> but before <code>next</code>, and may produce
<code>IllegalStateException</code>s or incorrect results from a <code>StAXSource</code> supplied
by PL/Java.</p></section><section>
<h3><a name="Compatibility_of_StAX_with_TrAX_.28Java.27s_transformation_API.29"></a>Compatibility of <code>StAX</code> with <code>TrAX</code> (Java's transformation API)</h3>
<p>The <code>javax.xml.transform</code> APIs are required to accept any of a specified
four types of <code>Source</code> and <code>Result</code>: <code>StreamSource</code>, <code>DOMSource</code>, <code>SAXSource</code>,
or <code>StAXSource</code> (and their <code>Result</code> counterparts). However, <code>StAX</code> was a later
addition to the family. While <code>TrAX</code> is a mature and reliable transformation
API, and <code>StAX</code> is well suited for direct use in new code that will parse or
generate XML, the handful of internal bridge classes that were added
to the Java runtime for <code>StAX</code> and <code>TrAX</code> interoperation are not dependable,
especially when handling <code>XML(CONTENT)</code>. When supplying a <code>Source</code> or <code>Result</code>
to a <code>Transformer</code>, a variant other than <code>StAX</code> should be chosen whenever
possible, whether PL/Java's or any other implementation.</p>
<p>For convenience, the <code>SQLXML</code> API allows passing a null value to <code>getSource</code>
or <code>setResult</code>, allowing the implementation to choose the type of <code>Source</code>
or <code>Result</code> to supply. PL/Java's implementation will never supply a <code>StAX</code>
variant when not explicitly requested.</p></section><section>
<h3><a name="Pay_no_attention_to_that_man_behind_the_curtain"></a>Pay no attention to that man behind the curtain</h3>
<p>The processing done &#x201c;behind the curtain&#x201d; to be able to handle <code>XML(CONTENT)</code>
and <code>XML(DOCUMENT)</code> form, when the form is not known in advance, can have
some visible effects when combined with the newer <a class="externalLink" href="https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html">security limit</a>
adjustments, or <code>schema</code> set on a SAX or DOM parser. For example, a very tight
setting of <code>maxElementDepth</code> may reveal that elements in the input are
nested one level deeper than expected, or a very tight <code>maxXMLNameLimit</code> may
reject a document whose expected names are all shorter. Schema validation for
some schemas and schema languages may likewise report an unexpected element
at the root of the document.</p>
<p>Issues with <code>maxElementDepth</code> or <code>maxXMLNameLimit</code> can be avoided by using
generous settings chosen to limit extreme resource consumption rather than
trying to set them as tightly as possible.</p>
<p>Problems with schema validation when assigning a <code>Schema</code> directly to the
SAX or DOM parser can be alleviated by using a <code>javax.xml.validation.Validator</code>
or <code>ValidatorHandler</code> instead, layered over PL/Java's parser, where it will
see the expected view of the content.</p></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2003&#x2013;2024<a href="http://tada.se/eng/">Tada AB</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
