<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/use/sqlxml.md at 2023-06-13

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>PostgreSQL PL/Java &#x2013; Working with XML</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean"><img src="../images/pljava_logo.jpg"  alt="PL/Java logo combining the PostgreSQL elephant and a Java bean"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2023-06-13</span>
          &#xA0;| <span id="projectVersion">Version: 1.6.5</span>
      </div>
      <div class="xright"><a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a> |
<a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a> |
<a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a> |
<a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Usage</h5>
    <ul>
     <li class="none"><a href="../build/build.html" title="Building PL/Java">Building PL/Java</a></li>
     <li class="none"><a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a></li>
     <li class="none"><a href="../install/upgrade.html" title="Upgrading">Upgrading</a></li>
     <li class="none"><a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a></li>
     <li class="none"><a href="../use/use.html" title="User guide">User guide</a></li>
     <li class="none"><a href="../develop/develop.html" title="Developer notes">Developer notes</a></li>
    </ul>
       <h5>Release Information</h5>
    <ul>
     <li class="none"><a href="../releasenotes.html" title="Release notes">Release notes</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a></li>
     <li class="none"><a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a></li>
     <li class="none"><a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a></li>
     <li class="none"><a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a></li>
     <li class="none"><a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a></li>
     <li class="none"><a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a></li>
     <li class="none"><a href="../pljava-pgxs/index.html" title="PL/Java PGXS">PL/Java PGXS</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="../project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>Working with XML</h1><section>
<h2><a name="In_PL.2FJava_before_1.5.1"></a>In PL/Java before 1.5.1</h2>
<p>PL/Java functions before 1.5.1 have been able to access a value of XML type as a <code>String</code> object. That has been workable, but an extra burden if porting code that used the JDBC 4.0 <code>java.sql.SQLXML</code> API, and with notable shortcomings.</p><section>
<h3><a name="Shortcomings"></a>Shortcomings</h3><section>
<h4><a name="Character_set_encoding"></a>Character set encoding</h4>
<p>PostgreSQL stores XML values serialized according to <code>server_encoding</code>, and depending on that setting, conversion to a Java <code>String</code> can involve transcoding.</p>
<p>XML has rules to handle characters that may be representable in one encoding but not another, but the <code>String</code> conversion is unaware of them, and may fail to produce a transcoding that represents the same XML value.</p></section><section>
<h4><a name="Memory_footprint"></a>Memory footprint</h4>
<p>While a database design using XML may be such that each XML datum is individually very small, it is also easy to store&#x2014;or generate in queries&#x2014;large XML values. When mapped to a Java <code>String</code>, such an XML value must have its full, uncompressed, character-serialized size allocated on the Java heap and be copied there from native memory, before the Java code even begins to make use of it. Even in cases where the Java processing to be done could be organized to stream through parse events in constant-bounded memory, the <code>String</code> representation forces the entire XML value to occupy Java memory at once. Any tuning of PL/Java&#x2019;s heap size allowance could have to consider a worst-case estimate of that size, or risk failures at run time.</p></section></section></section><section>
<h2><a name="The_JDBC_4.0_java.sql.SQLXML_API"></a>The JDBC 4.0 <code>java.sql.SQLXML</code> API</h2>
<p>PL/Java 1.5.1 adds support for this API. A Java parameter or return type in a a PL/Java function can be declared to be <code>SQLXML</code>, and such objects can be retrieved from <code>ResultSet</code> and <code>SQLInput</code> objects, and used as <code>PreparedStatement</code> parameters or in <code>SQLOutput</code> and updatable <code>ResultSet</code> objects.</p><section>
<h3><a name="Reading_a_PostgreSQL_XML_value_as_a_readable_SQLXML_object"></a>Reading a PostgreSQL XML value as a <i>readable</i> <code>SQLXML</code> object</h3>
<p>An <code>SQLXML</code> instance can have the &#x201c;conceptual states&#x201d; <i>readable</i> and <i>not readable</i>, <i>writable</i> and <i>not writable</i>. In PL/Java, an instance passed in as a parameter to a function, or retrieved from a <code>ResultSet</code>, is <i>readable</i> and <i>not writable</i>, and can be used as input to Java processing using any of the following methods:</p>
<dl>

<dt><code>getBinaryStream()</code></dt>
<dd>Obtain an <code>InputStream</code> with the raw, byte-stream-serialized XML, which will have to be passed to an XML parser. The parser will have to determine the encoding used from the declaration at the start of the stream, or assume UTF-8 if there is none, as the standard provides.</dd>
<dt><code>getCharacterStream()</code></dt>
<dd>Like <code>getBinaryStream</code> but as a stream of Java characters, with the underlying encoding already decoded. May be convenient for use with parsing code that isn&#x2019;t able to recognize and honor the encoding declaration, but any standard XML parser would work as well from <code>getBinaryStream</code>, which should be preferred when possible. A parser working from the binary stream is able to handle transcoding, if needed, in an XML-aware way. With this method, any needed transcoding is done without XML-awareness to produce the character stream.</dd>
<dt><code>getString()</code></dt>
<dd>Obtain the entire serialized XML value decoded as a Java <code>String</code>. Has the same memory footprint and encoding implications discussed for the legacy conversion to <code>String</code>, but may be convenient for some purposes or for values known to be small.</dd>
<dt><code>getSource(javax.xml.transform.stream.StreamSource.class)</code></dt>
<dd>Equivalent to one of the first two methods, but with the stream wrapped in a <code>Source</code> object, directly usable with Java XML transformation APIs.</dd>
<dt><code>getSource(javax.xml.transform.sax.SAXSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object that presents the XML in parsed form via the SAX API, where the caller can register callback methods for XML constructs of interest, and then have Java stream through the XML value, calling those methods.</dd>
<dt><code>getSource(javax.xml.transform.sax.StAXSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object that presents the XML in parsed form via the StAX API, where the value can be streamed through by calling StAX pull methods to get one XML construct at a time. Java code written to this API can more clearly reflect the expected structure of the XML document, compared to code written in the callback style for SAX.</dd>
<dt><code>getSource(javax.xml.transform.sax.DOMSource.class)</code></dt>
<dd>Obtain a <code>Source</code> object presenting the XML fully parsed as a navigable, in-memory DOM tree.</dd>
<dt><code>getSource(null)</code></dt>
<dd>Obtain a <code>Source</code> object of a type chosen by the implementation. Useful when the <code>Source</code> object will be passed to a standard Java transformation API, which can handle any of the above forms, letting the <code>SQLXML</code> implementation choose one that it implements efficiently.</dd>
</dl>
<p>Exactly one of these methods can be called exactly once on a <i>readable</i> <code>SQLXML</code> object, which is thereafter <i>not readable</i>. (The <i>not readable</i> state prevents a second call to any of the getter methods; it does not, of course, prevent reading the XML content through the one stream, <code>String</code>, or <code>Source</code> obtained from the getter method that was just called.)</p>
<p>Except in the <code>String</code> or DOM form, which bring the entire XML value into Java memory at once, the XML content is streamed directly from native PostgreSQL memory as Java code reads it, never accumulating in the Java heap unless that is what the application code does with it. Java heap sizing, therefore, can be based on just what the application Java code will do with the data.</p>
<p>The most convenient API to use in an application will often be SAX or StAX, in which the code can operate at the level of already-parsed, natural XML constructs. Code designed to work with a navigable DOM tree can easily obtain that form (but it should be understood that DOM will pull the entire content into Java memory at once, in a memory-hungry form that can easily be twenty times the size of the serialized value).</p><section>
<h4><a name="Obtaining_a_readable_SQLXML_object"></a>Obtaining a <i>readable</i> <code>SQLXML</code> object</h4>
<p>To obtain a <i>readable</i> instance, declare <code>java.sql.SQLXML</code> as the type of a function parameter where PostgreSQL will pass an XML argument, or use the <code>getSQLXML</code> or <code>getObject(..., SQLXML.class)</code> methods on a <code>ResultSet</code>, or the <code>readSQLXML</code> or <code>readObject(SQLXML.class)</code> methods on <code>SQLInput</code>. A fully JDBC-4.0 compliant driver would also return <code>SQLXML</code> instances from the non-specific <code>getObject</code> and <code>readObject</code> methods, but in PL/Java, those have historically returned <code>String</code>. Because 1.5.1 is not a major release, their behavior has not changed, and the more-specific methods must be used to obtain <code>SQLXML</code> instances.</p></section></section><section>
<h3><a name="Creating.2Freturning_a_PostgreSQL_XML_value_with_a_writable_SQLXML_object"></a>Creating/returning a PostgreSQL XML value with a <i>writable</i> <code>SQLXML</code> object</h3>
<p>PL/Java will supply an empty <code>SQLXML</code> instance that is <i>writable</i> and <i>not readable</i> via the <code>Connection</code> method <code>createSQLXML()</code>. It can be used as an output destination for any of several Java XML APIs, through a selection of <code>set...</code> methods exactly mirroring the available <code>get...</code> methods described above.</p>
<p><i>The API is unusual: except for <code>setString</code>, which takes a <code>String</code> parameter and returns <code>void</code> as a typical &#x201c;setter&#x201d; method would, the other setter methods are used for the object they return&#x2014;an <code>OutputStream</code>, <code>Writer</code>, or <code>Result</code>&#x2014;which the calling code should then use to add content to the XML value.</i></p>
<p>Exactly one setter method can be called exactly once on a <i>writable</i> <code>SQLXML</code> object, which is thereafter <i>not writable</i>. (The <i>not writable</i> state prevents a second call to any setter method; XML content must still be written via the stream or <code>Result</code> obtained from the one setter that was just called, except in the case of <code>setString</code>, which populates the value at once.) Content being written to the <code>SQLXML</code> object is accumulated in PostgreSQL native memory, not the Java heap.</p>
<p>A <code>SQLXML</code> object, once it has been fully written and closed, can be returned from a Java function, passed as a <code>PreparedStatement</code> parameter to a nested query, or stored into writable <code>ResultSet</code>s used for composite function or trigger results. It can be used exactly once in any of those ways, which transfer its ownership back to PostgreSQL, leaving it inaccessible from Java.</p><section>
<h4><a name="When_a_writable_SQLXML_object_is_considered_closed"></a>When a <i>writable</i> <code>SQLXML</code> object is considered closed</h4>
<p>A <i>writable</i> <code>SQLXML</code> object cannot be presented to PostgreSQL before it is closed to confirm that writing is complete. (One written by <code>setString</code> is considered written, closed, and ready to use immediately.)</p>
<p>When it is written using a stream obtained from <code>setBinaryStream</code>, <code>setCharacterStream</code>, or <code>setResult(javax.xml.transform.stream.StreamResult.class)</code>, it is considered closed when the stream&#x2019;s <code>close</code> method is called. This will typically <i>not</i> be done by a Java <code>Transformer</code> with the stream as its result, and so should be explicitly called after such a transformation completes.</p>
<p>When written using a <code>SAXResult</code>, it is considered closed when the <code>ContentHandler</code>&#x2019;s <code>endDocument</code> method is called, and when written using a <code>StAXResult</code>, it is considered closed when the <code>XMLStreamWriter</code>&#x2019;s <code>writeEndDocument</code> method is called. When one of these flavors of <code>Result</code> is used with a Java <code>Transformer</code>, these methods will have been called in the normal course of the transformation, so nothing special needs to be done after the transformation completes.</p>
<p>What it means to <code>close</code> a <code>DOMResult</code> is murkier. The application code must call the <code>DOMResult</code>&#x2019;s <code>setNode</code> method, passing what will be the root node of the result document. This can be done before or after (or while) child nodes and content are added to that node. However, to avoid undefined behavior, application code must make no further modification to that DOM tree after the <code>SQLXML</code> object has been presented to PostgreSQL (whether via a <code>PreparedStatement</code> <code>set</code> method, <code>ResultSet</code> <code>update</code> method, <code>SQLOutput</code> <code>write</code> method, or returned as the function result).</p></section><section>
<h4><a name="Using_a_Result_object_as_a_Transformer_result"></a>Using a <code>Result</code> object as a <code>Transformer</code> result</h4>
<p>Classes that extend <code>javax.xml.transform.Transformer</code> will generally accept any flavor of <code>Result</code> object and select the right API to write the transformation result to it. There is often no need to care which <code>Result</code> flavor to provide, so it is common to call <code>setResult(null)</code> to let the <code>SQLXML</code> implementation itself choose a flavor based on implementation-specific efficiency considerations.</p>
<p>In the case of a <code>DOMResult</code>, if the <code>Result</code> object is simply passed to a <code>Transformer</code> without calling <code>setNode</code> first, the <code>Transformer</code> itself will put an empty <code>Document</code> node there, which is then populated with the transformation results.</p>
<p>A <code>Document</code> node, however, enforces conformance to the strict rules of <code>XML(DOCUMENT)</code> form (described below). If the content to be written will conform only to the looser rules of <code>XML(CONTENT)</code> form, application code should call <code>setNode</code> supplying an empty <code>DocumentFragment</code> node, before passing the <code>Result</code> object to a <code>Transformer</code>.</p>
<p>The flavor of <code>Result</code> returned by <code>setResult(null)</code> will never (in PL/Java) be <code>DOMResult</code>.</p></section></section><section>
<h3><a name="Using_an_unread_readable_SQLXML_object_as_a_written_one"></a>Using an unread <i>readable</i> <code>SQLXML</code> object as a written one</h3>
<p>The general rule that only a <i>writable</i> instance (that has been written and closed) can be used as a function result, or passed into a nested query, admits one exception, allowing a <i>readable</i> instance that Java code has obtained but not read. That makes it simple for Java code to obtain an <code>SQLXML</code> instance passed in as a parameter, or from a query, and use it directly as a result or a nested-query parameter. Any one instance can be used this way no more than once.</p></section><section>
<h3><a name="XML.28DOCUMENT.29_and_XML.28CONTENT.29"></a><code>XML(DOCUMENT)</code> and <code>XML(CONTENT)</code></h3>
<p>An XML value in SQL can have the type <code>XML(DOCUMENT)</code> or <code>XML(CONTENT)</code> (as those are defined in the ISO SQL standard, 2006 and later), which PostgreSQL does not currently treat as distinguishable types. The <code>DOCUMENT</code> form must have exactly one root element, may have a document-type declaration (DTD), and has strict limits on where other constructs (other than comments and processing instructions) can occur. A value in <code>CONTENT</code> form may have no root element, or more than one element at top level, and other constructs such as character data outside of a root element where <code>DOCUMENT</code> form would not allow them.</p><section>
<h4><a name="How_both_forms_are_accommodated_when_reading"></a>How both forms are accommodated when reading</h4>
<p>Java code using a <i>readable</i> <code>SQLXML</code> instance as input should be prepared to encounter either form (unless it has out-of-band knowledge of which form will be supplied). If it requests a <code>DOMSource</code>, <code>getNode()</code> will return a <code>Document</code> node, if the value met all the requirements for <code>DOCUMENT</code>, or a <code>DocumentFragment</code> node, if it was parsable as <code>CONTENT</code>. Java code requesting a <code>SAXSource</code> or <code>StAXSource</code> should be prepared to handle a sequence of constructs that might not be encountered when parsing a strictly conforming <code>DOCUMENT</code>. Java code that requests an <code>InputStream</code>, <code>Reader</code>, <code>String</code>, or <code>StreamSource</code> will be on its own to parse the data in whichever form appears.</p><section>
<h5><a name="Effect_on_parsing_of_whitespace"></a>Effect on parsing of whitespace</h5>
<p>In <code>DOCUMENT</code> form, any whitespace outside of the single root element is considered markup, not character data. When the value is parsable as <code>DOCUMENT</code>, and read through PL/Java&#x2019;s <code>SAXSource</code> or <code>StAXSource</code>, no whitespace that occurs outside of the root element will be reported to the application. PL/Java&#x2019;s <code>DOMSource</code> will present a <code>Document</code> node with no whitespace text-node children outside of the root element.</p>
<p>If the value parses as <code>CONTENT</code>, PL/Java&#x2019;s <code>DOMSource</code> will present a <code>DocumentFragment</code> node with all character data, including whitespace, preserved. The streaming operation of the <code>SAXSource</code> and <code>StAXSource</code> is more complicated, and lossy for whitespace (only if it occurs outside of any element) ahead of the first parse event that would not be possible in <code>DOCUMENT</code> form. All whitespace beyond that point is preserved.</p></section></section><section>
<h4><a name="How_both_forms_are_accommodated_when_writing"></a>How both forms are accommodated when writing</h4>
<p>Java code using a <i>writable</i> SQLXML instance to produce a result may write either <code>DOCUMENT</code> or <code>CONTENT</code> form. If using <code>DOMResult</code>, it must supply a <code>DocumentFragment</code> node to produce a <code>CONTENT</code> result, as a <code>Document</code> node will enforce the <code>DOCUMENT</code> requirements.</p></section></section><section>
<h3><a name="An_SQLXML_object_has_transaction_lifetime"></a>An <code>SQLXML</code> object has transaction lifetime</h3>
<p>The JDBC spec provides that an <code>SQLXML</code> instance is &#x201c;valid for the duration of the transaction in which it was created.&#x201d; One PL/Java function can hold an <code>SQLXML</code> instance (in a static or session variable or data structure), and other PL/Java functions called later in the same transaction can continue reading from or writing to it. If the transaction has committed or rolled back, those operations will generate an exception.</p>
<p>Once a <i>writable</i> <code>SQLXML</code> object, or an unread, <i>readable</i> one, has been presented to PostgreSQL as the result of a PL/Java function or through a <code>PreparedStatement</code>/<code>ResultSet</code>/<code>SQLOutput</code> setter method, it is no longer accessible in Java.</p>
<p>During a transaction, resources held by a <code>SQLXML</code> object are reclaimed as soon as a <i>readable</i> one has been fully read, or a <i>writable</i> one has been presented to PostgreSQL and PostgreSQL is done with it. If application code holds a readable <code>SQLXML</code> object that it determines it will not read, or a writable one it will not present to PostgreSQL, it can call the <code>free</code> method to allow the resources to be reclaimed sooner than the transaction&#x2019;s end.</p></section><section>
<h3><a name="Lazy_detoasting"></a>Lazy detoasting</h3>
<p>PostgreSQL can represent large XML values in &#x201c;TOASTed&#x201d; form, which may be in memory but compressed (XML typically compresses to a small fraction of its serialized size), or may be a small pointer to a location in storage. A <i>readable</i> <code>SQLXML</code> instance over a TOASTed value will not be detoasted until Java code actually begins to read it, so the memory footprint of an instance being held but not yet read is kept low.</p></section><section>
<h3><a name="Validation_of_content"></a>Validation of content</h3>
<p>Some of the methods by which a <i>writable</i> instance can be written are not XML-specific APIs, but allow arbitrary content to be written (as a <code>String</code>, <code>Writer</code>, or <code>OutputStream</code>). When written by those methods, type safety is upheld by verifying that the written content can be successfully reparsed, accepting either <code>DOCUMENT</code> or <code>CONTENT</code> form.</p>
<p>It remains possible to declare the Java type <code>String</code> for function parameters and returns of XML type, and to retrieve and supply <code>String</code> for <code>ResultSet</code> columns and <code>PreparedStatement</code> parameters of XML type. This legacy mapping from <code>String</code> to XML uses PostgreSQL&#x2019;s <code>xml_in</code> function to verify the form of a <code>String</code> from Java. That function may reject some valid values if the server configuration variable <code>xmloption</code> is not first set to <code>DOCUMENT</code> or <code>CONTENT</code> to match the type of the value.</p><section>
<h4><a name="Validation_against_a_schema"></a>Validation against a schema</h4>
<p>Java&#x2019;s XML APIs support validation using a choice of schema languages; support for XML Schema 1.0 is included in the Java runtime, and implementations of others can be placed on the class path.</p>
<p>A <code>schema</code> method is available through the &#x201c;Extended API to configure XML parsers&#x201d; described below, but will only work on a <code>SAXSource</code> or <code>DOMSource</code> (or a <code>StreamResult</code>, which uses a SAX parser to validate the stream written). Other limitations are described under &#x201c;known limitations&#x201d; below.</p>
<p>More flexibly, <code>javax.xml.validation.Validator</code> or <code>javax.xml.validation.ValidatorHandler</code> can be used in more situations and with fewer limitations.</p></section></section><section>
<h3><a name="Usable_with_or_without_native_XML_support_in_PostgreSQL"></a>Usable with or without native XML support in PostgreSQL</h3>
<p>In symmetry to using Java <code>String</code> for SQL XML types, PL/Java allows the Java <code>SQLXML</code> type to be used with PostgreSQL data of type <code>text</code>. This allows full use of the Java XML APIs even in PostgreSQL instances built without XML support. All of the <code>SQLXML</code> behaviors described above also apply in this usage.</p>
<p>If a <i>readable</i> <code>SQLXML</code> instance obtained from a <code>text</code> value is directly used to set or return a value of PostgreSQL&#x2019;s XML type, the XML-ness of the content is verified.</p></section></section><section>
<h2><a name="Extensions_to_the_java.sql.SQLXML_API"></a>Extensions to the <code>java.sql.SQLXML</code> API</h2><section>
<h3><a name="Extended_API_to_configure_XML_parsers"></a>Extended API to configure XML parsers</h3>
<p>Retrieving or verifying the XML content in an <code>SQLXML</code> object can involve applying an XML parser. The full XML specification includes features that can require an XML parser to retrieve external resources or consume unexpected amounts of memory. The full feature support may be an asset in an environment where the XML content will always be from a known, trusted source, or a liability if less is known about the XML content being processed.</p>
<p>The <a class="externalLink" href="https://www.owasp.org/index.php/About_The_Open_Web_Application_Security_Project">Open Web Application Security Project</a> (OWASP) advocates for the default use of settings that strictly limit the related features of Java XML parsers, as outlined in a <a class="externalLink" href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java">&#x201c;cheat sheet&#x201d;</a> the organization publishes.</p>
<p>However, the recommended defaults really are severely restrictive (for example, disabling document-type declarations by default will cause PL/Java&#x2019;s <code>SQLXML</code> implementation to reject all XML values that contain DTDs). Therefore, there must be a simple and clear way for code to selectively adjust the settings, or adopting the strictest settings by default would pose an unacceptable burden to developers.</p>
<p>The traditional Java way to adjust the XML parser is overwhelmingly fiddly, involving <code>setFeature</code> or <code>setProperty</code> calls that identify the feature to be set by passing an arcane URI that might be found in the documentation, or the <a class="externalLink" href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java">cheat sheet</a>, or cargo-culted from some other code base. In some cases, the streamlined <code>SQLXML</code> API conceals the steps where adjustments would have to be applied. With no better way to adjust the parser, it would be an unrealistic developer burden to adopt the restrictive defaults and expect the developer to relax them.</p>
<p>Therefore, PL/Java has an extension API documented at the <a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">org.postgresql.pljava.Adjusting.XML class</a>. With the API, it is possible to obtain a <code>Source</code> object from an <code>SQLXML</code> instance <code>sqx</code> in either the standard or extended way shown in this example for a <code>SAXSource</code>:</p>

<div class="source">
<div class="source">
<pre>SAXSource src = sqx.getSource(SAXSource.class); // OR
SAXSource src = sqx.getSource(Adjusting.XML.SAXSource.class)
                   .allowDTD(true).get();
</pre></div></div>

<p>The first form would obtain a <code>SAXSource</code> configured with the restrictive, OWASP-recommended defaults, which would reject any content with a DTD. The second form would obtain a <code>SAXSource</code> configured to allow a DTD in the content, with other parser features left at the restrictive defaults.</p><section>
<h4><a name="Additional_adjustments_in_recent_Java_versions"></a>Additional adjustments in recent Java versions</h4>
<p>Additional security-related adjustments have appeared in various Java releases, and are described in the <a class="externalLink" href="https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html">Java API for XML Processing Security Guide</a>. They include a number of configurable limits on maximum sizes and nesting depths, and limits to the set of protocols allowable for fetching external resources. Corresponding methods are provided in <a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">PL/Java&#x2019;s API</a>. Also see &#x201c;known limitations&#x201d; below.</p></section><section>
<h4><a name="Supplying_a_SAX_or_DOM_EntityResolver_or_Schema"></a>Supplying a SAX or DOM <code>EntityResolver</code> or <code>Schema</code></h4>
<p>Methods are provided to set an <code>EntityResolver</code> that controls how a SAX or DOM parser resolves references to external entities, or a <code>Schema</code> by which a SAX or DOM parser can validate content while parsing. Corresponding methods are supplied in PL/Java&#x2019;s API, but are implemented only when operating on a <code>SAXSource</code> or <code>DOMSource</code> (or <code>StreamResult</code>, affecting its validation of the content written).</p>
<p>For StAX, control of resolution is done with a slightly different class, <code>XMLResolver</code>, which can be set on a StAX parser as an ordinary property; this can be done with PL/Java&#x2019;s <code>setFirstMatchingProperty</code> method.</p>
<p>A StAX parser cannot have a <code>Schema</code> directly assigned, but can be used with a <code>javax.xml.validation.Validator</code>.</p>
<p>Complete details can be found <a href="../pljava-api/apidocs/org.postgresql.pljava/org/postgresql/pljava/Adjusting.XML.html">in the API documentation</a>.</p></section><section>
<h4><a name="Using_XML_Catalogs_when_running_on_Java_9_or_later"></a>Using XML Catalogs when running on Java 9 or later</h4>
<p>When running on Java 9 or later, a local XML Catalog can be set up to efficiently and securely resolve what would otherwise be external resource references. The registration of a Catalog on a Java 9 or later parser involves only existing methods for setting features/properties, as described <a class="externalLink" href="https://docs.oracle.com/javase/9/core/xml-catalog-api1.htm#JSCOR-GUID-51446739-F878-4B70-A36F-47FBBE12A26A">in the Catalog API documentation</a>, and can be done with the <code>setFirstSupportedFeature</code> and <code>setFirstSupportedProperty</code> methods in PL/Java&#x2019;s <code>Adjusting</code> API.</p></section></section><section>
<h3><a name="Extended_API_to_set_the_content_of_a_PL.2FJava_SQLXML_instance"></a>Extended API to set the content of a PL/Java <code>SQLXML</code> instance</h3>
<p>When a <code>SQLXML</code> instance is returned from a PL/Java function, or passed in to a PL/Java <code>ResultSet</code> or <code>PreparedStatement</code>, it is used directly if it is an instance of PL/Java&#x2019;s internal implementation.</p>
<p>However, a PL/Java function might reasonably use another JDBC driver and obtain a <code>SQLXML</code> instance from a connection to some other database. If such a &#x2018;foreign&#x2019; <code>SQLXML</code> object is returned from a function, or passed to a PL/Java <code>ResultSet</code> or <code>PreparedStatement</code>, its content must first be copied to a new instance created by PL/Java&#x2019;s driver. This happens transparently (but implies that the &#x2018;foreign&#x2019; instance must be in <i>readable</i> state at the time, and afterward will not be).</p>
<p>The transparent copy is made by passing <code>null</code> as <code>sourceClass</code> to the foreign object&#x2019;s <code>getSource</code> method, so the foreign object is in control of the type of <code>Source</code> it will return. PL/Java will copy from a <code>StreamSource</code>, <code>SAXSource</code>, <code>StAXSource</code>, or <code>DOMSource</code>. In the case of a <code>StreamSource</code>, an XML parser will be involved, either to verify that the stream is XML, or to parse and reserialize it if necessary to adapt its encoding to the server&#x2019;s. The parser used by default will have the default, restrictive settings.</p>
<p>To allow adjustment of those settings, the copying operation can be invoked explicitly through the <code>Adjusting.XML.SourceResult</code> class. For example, when <i>sx</i> is a &#x2018;foreign&#x2019; <code>SQLXML</code> object, the transparent operation</p>

<div class="source">
<div class="source">
<pre>return sx;
</pre></div></div>

<p>is equivalent to</p>

<div class="source">
<div class="source">
<pre>return conn.createSQLXML().setResult(Adjusting.XML.SourceResult.class)
           .set(sx.getSource(null)).get().getSQLXML();
</pre></div></div>

<p>where <i>conn</i> is the PL/Java JDBC connection named by <code>jdbc:default:connection</code>. To adjust the parser settings, as usual, adjusting methods can be chained after the <code>set</code> and before the <code>get</code>. The explicit form also allows passing a <code>sourceClass</code> other than <code>null</code> to the foreign object&#x2019;s <code>getSource</code> method, if there is a reason not to let the foreign object choose the type of <code>Source</code> to return.</p></section><section>
<h3><a name="SQLXML_views_of_non-XML_data"></a><code>SQLXML</code> views of non-XML data</h3>
<p>There are the beginnings of a feature supporting <a href="xmlview.html">XML views of non-XML data</a>, so that some data types that are not XML, but are similarly tree-structured, can be manipulated in Java using Java&#x2019;s extensive support for XML.</p></section></section><section>
<h2><a name="Known_limitations"></a>Known limitations</h2><section>
<h3><a name="Limitations_of_StAX_support"></a>Limitations of <code>StAX</code> support</h3>
<p>PL/Java&#x2019;s <code>StAXSource</code> supplies an <code>XMLStreamReader</code> that only supports the expected usage pattern:</p>

<div class="source">
<div class="source">
<pre>while ( streamReader.hasNext() )
{
  streamReader.next();
  /* methods that query state of the current parse event */
}
</pre></div></div>

<p>It would be unexpected to reorder that pattern so that queries of the current event occur after <code>hasNext</code> but before <code>next</code>, and may produce <code>IllegalStateException</code>s or incorrect results from a <code>StAXSource</code> supplied by PL/Java.</p></section><section>
<h3><a name="Compatibility_of_StAX_with_TrAX_.28Java.E2.80.99s_transformation_API.29"></a>Compatibility of <code>StAX</code> with <code>TrAX</code> (Java&#x2019;s transformation API)</h3>
<p>The <code>javax.xml.transform</code> APIs are required to accept any of a specified four types of <code>Source</code> and <code>Result</code>: <code>StreamSource</code>, <code>DOMSource</code>, <code>SAXSource</code>, or <code>StAXSource</code> (and their <code>Result</code> counterparts). However, <code>StAX</code> was a later addition to the family. While <code>TrAX</code> is a mature and reliable transformation API, and <code>StAX</code> is well suited for direct use in new code that will parse or generate XML, the handful of internal bridge classes that were added to the Java runtime for <code>StAX</code> and <code>TrAX</code> interoperation are not dependable, especially when handling <code>XML(CONTENT)</code>. When supplying a <code>Source</code> or <code>Result</code> to a <code>Transformer</code>, a variant other than <code>StAX</code> should be chosen whenever possible, whether PL/Java&#x2019;s or any other implementation.</p>
<p>For convenience, the <code>SQLXML</code> API allows passing a null value to <code>getSource</code> or <code>setResult</code>, allowing the implementation to choose the type of <code>Source</code> or <code>Result</code> to supply. PL/Java&#x2019;s implementation will never supply a <code>StAX</code> variant when not explicitly requested.</p></section><section>
<h3><a name="Pay_no_attention_to_that_man_behind_the_curtain"></a>Pay no attention to that man behind the curtain</h3>
<p>The processing done &#x201c;behind the curtain&#x201d; to be able to handle <code>XML(CONTENT)</code> and <code>XML(DOCUMENT)</code> form, when the form is not known in advance, can have some visible effects when combined with the newer <a class="externalLink" href="https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html">security limit</a> adjustments, or <code>schema</code> set on a SAX or DOM parser. For example, a very tight setting of <code>maxElementDepth</code> may reveal that elements in the input are nested one level deeper than expected, or a very tight <code>maxXMLNameLimit</code> may reject a document whose expected names are all shorter. Schema validation for some schemas and schema languages may likewise report an unexpected element at the root of the document.</p>
<p>Issues with <code>maxElementDepth</code> or <code>maxXMLNameLimit</code> can be avoided by using generous settings chosen to limit extreme resource consumption rather than trying to set them as tightly as possible.</p>
<p>Problems with schema validation when assigning a <code>Schema</code> directly to the SAX or DOM parser can be alleviated by using a <code>javax.xml.validation.Validator</code> or <code>ValidatorHandler</code> instead, layered over PL/Java&#x2019;s parser, where it will see the expected view of the content.</p></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2003&#x2013;2023<a href="http://tada.se/eng/">Tada AB</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
