# This workflow will build and test PL/Java against the version of PostgreSQL
# preinstalled in the GitHub Actions runner environment.

name: PL/Java CI with PostgreSQL version supplied by the runner

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    if: true

    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        java: [9] # , 11, 12, 14, 15-ea]

    steps:

    - name: Check out PL/Java
      uses: actions/checkout@v2
      with:
        path: pljava

    - name: Set up JDK
      uses: actions/setup-java@v1
      with:
        java-version: ${{ matrix.java }}

    - name: Report Java, Maven, and PostgreSQL versions
      run: |
        java -version
        mvn --version
        pg_config

    - name: Obtain PG development files (Ubuntu, PGDG)
      if: ${{ 'Linux' == runner.os }}
      run: sudo apt-get install postgresql-server-dev-12 libkrb5-dev

    - name: Build PL/Java
      working-directory: pljava
      run: |
        mvn clean install --batch-mode \
          -Psaxon-examples -Ppgjdbc-ng \
          -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn

    - name: Install and test PL/Java
      working-directory: pljava
      run: |
        pgConfig=pg_config # runner-supplied, just get it from the PATH

        packageJar=$(find pljava-packaging -name pljava-pg*.jar -print)

        mavenRepo="$HOME/.m2/repository"

        saxonVer=$(
          find "$mavenRepo/net/sf/saxon/Saxon-HE" \
            -name 'Saxon-HE-*.jar' -print |
          sort |
          tail -n 1
        )
        saxonVer=${saxonVer%/*}
        saxonVer=${saxonVer##*/}

        jdbcJar=$(
          find "$mavenRepo/com/impossibl/pgjdbc-ng/pgjdbc-ng-all" \
            -name 'pgjdbc-ng-all-*.jar' -print |
          sort |
          tail -n 1
        )

        sudo java -Dpgconfig="$pgConfig" -jar "$packageJar"

        jshell \
          -execution local \
          "-J--class-path=$packageJar:$jdbcJar" \
          "--class-path=$packageJar" \
          "-J--add-modules=java.sql,java.sql.rowset" \
          "-J-Dpgconfig=$pgConfig" \
          "-J-Dcom.impossibl.shadow.io.netty.noUnsafe=true" \
          "-J-DmavenRepo=$mavenRepo" \
          "-J-DsaxonVer=$saxonVer" - <<\ENDJSHELL

        boolean succeeding = false; // begin pessimistic

        import static java.nio.file.Paths.get
        import java.sql.Connection
        import org.postgresql.pljava.packaging.Node
        import static org.postgresql.pljava.packaging.Node.q
        import static org.postgresql.pljava.packaging.Node.dfa
        import static org.postgresql.pljava.packaging.Node.isVoidResultSet

        Path javaLibDir = get(System.getProperty("java.home"), "lib")

        Path libjvm = (
          "Mac OS X".equals(System.getProperty("os.name"))
          ? Stream.of("libjli.dylib", "jli/libjli.dylib")
            .map(s -> javaLibDir.resolve(s))
            .filter(Files::exists).findFirst().get()
          : javaLibDir.resolve("server/libjvm.so")
        );

        String vmopts = "-enableassertions:org.postgresql.pljava... -Xcheck:jni"

        Node n1 = Node.get_new_node("TestNode1")

        /*
         * Keep a tally of the three types of diagnostic notices that may be
         * received, and, independently, how many represent no-good test results
         * (error always, but also warning if seen from the tests in the
         * examples.jar deployment descriptor).
         */
        Map<String,Integer> results =
          Stream.of("info", "warning", "error", "ng").collect(
            LinkedHashMap<String,Integer>::new,
            (m,k) -> m.put(k, 0), (r,s) -> {})

        boolean isDiagnostic(Object o, Set<String> whatIsNG)
        {
          if ( ! ( o instanceof Throwable ) )
            return false;
          String[] parts = Node.classify((Throwable)o);
          String type = parts[0];
          results.compute(type, (k,v) -> 1 + v);
          if ( whatIsNG.contains(type) )
            results.compute("ng", (k,v) -> 1 + v);
          return true;
        }

        try (
          AutoCloseable t1 = n1.initialized_cluster();
          AutoCloseable t2 = n1.started_server(Map.of(
            "client_min_messages", "info",
            "pljava.vmoptions", vmopts,
            "pljava.libjvm_location", libjvm.toString()
          ));
        )
        {
          try ( Connection c = n1.connect() )
          {
            succeeding = true; // become optimistic, will be using &= below

            succeeding &= dfa(
              "create extension no result",
              null,

              q(c, "create extension pljava")
              .flatMap(Node::semiFlattenDiagnostics)
              .peek(Node::peek),

              // state 1: consume any diagnostics, or to state 2 with same item
              (o,p,q) -> isDiagnostic(o, Set.of("error")) ? 1 : -2,

              // state 2: must be end of input
              (o,p,q) -> null == o
            );
          }

          /*
           * Get a new connection; 'create extension' always sets a near-silent
           * logging level, and PL/Java only checks once at VM start time, so in
           * the same session where 'create extension' was done, logging is
           * somewhat suppressed.
           */
          try ( Connection c = n1.connect() )
          {
            succeeding &= dfa(
              "saxon path examples path",
              null,

              Node.installSaxonAndExamplesAndPath(c,
                System.getProperty("mavenRepo"),
                System.getProperty("saxonVer"),
                true)
              .flatMap(Node::semiFlattenDiagnostics)
              .peek(Node::peek),

              // states 1,2: diagnostics* then a void result set (saxon install)
              (o,p,q) -> isDiagnostic(o, Set.of("error")) ? 1 : -2,
              (o,p,q) -> isVoidResultSet(o, 1, 1) ? 3 : false,

              // states 3,4: diagnostics* then a void result set (set classpath)
              (o,p,q) -> isDiagnostic(o, Set.of("error")) ? 3 : -4,
              (o,p,q) -> isVoidResultSet(o, 1, 1) ? 5 : false,

              // states 5,6: diagnostics* then void result set (example install)
              (o,p,q) -> isDiagnostic(o, Set.of("error", "warning")) ? 5 : -6,
              (o,p,q) -> isVoidResultSet(o, 1, 1) ? 7 : false,

              // states 7,8: diagnostics* then a void result set (set classpath)
              (o,p,q) -> isDiagnostic(o, Set.of("error")) ? 7 : -8,
              (o,p,q) -> isVoidResultSet(o, 1, 1) ? 9 : false,

              // state 9: must be end of input
              (o,p,q) -> null == o
            );
          }
        } catch ( Throwable t )
        {
          succeeding = false;
          throw t;
        }

        System.out.println(results);
        succeeding &= (0 == results.get("ng"));
        System.exit(succeeding ? 0 : 1)
        ENDJSHELL
