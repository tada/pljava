<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/releasenotes-pre1_6.md.vm at 2020-11-27

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>PostgreSQL PL/Java &#x2013; Release notes, releases prior to PL/Java 1.6</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean"><img src="images/pljava_logo.jpg"  alt="PL/Java logo combining the PostgreSQL elephant and a Java bean"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2020-11-27</span>
          &#xA0;| <span id="projectVersion">Version: 1.6.2</span>
      </div>
      <div class="xright"><a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a> |
<a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a> |
<a href="https://www.postgresql.org/list/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a> |
<a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Usage</h5>
    <ul>
     <li class="none"><a href="build/build.html" title="Building PL/Java">Building PL/Java</a></li>
     <li class="none"><a href="install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a></li>
     <li class="none"><a href="install/upgrade.html" title="Upgrading">Upgrading</a></li>
     <li class="none"><a href="build/package.html" title="Packaging PL/Java">Packaging PL/Java</a></li>
     <li class="none"><a href="use/use.html" title="User guide">User guide</a></li>
     <li class="none"><a href="develop/develop.html" title="Developer notes">Developer notes</a></li>
    </ul>
       <h5>Release Information</h5>
    <ul>
     <li class="none"><a href="releasenotes.html" title="Release notes">Release notes</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="pljava-api/index.html" title="PL/Java API">PL/Java API</a></li>
     <li class="none"><a href="pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a></li>
     <li class="none"><a href="pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a></li>
     <li class="none"><a href="pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a></li>
     <li class="none"><a href="pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a></li>
     <li class="none"><a href="pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a></li>
     <li class="none"><a href="pljava-pgxs/index.html" title="PL/Java PGXS">PL/Java PGXS</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<h1>Release notes, releases prior to PL/Java 1.6</h1><section><section>
<h3><a name="PL.2FJava_1.5.7"></a>PL/Java 1.5.7</h3>
<p>1.5.7 is a bug-fix release, with a single issue backpatched from the 1.6 branch, correcting a problem in XML Schema validation in some non-<code>en_US</code> locales.</p><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/312">XML Schema regression-test failure in de_DE locale</a></li>
</ul></section><section>
<h4><a name="Credits"></a>Credits</h4>
<p>Thanks to Christoph Berg for the report.</p></section></section><section>
<h3><a name="PL.2FJava_1.5.6_.284_October_2020.29"></a>PL/Java 1.5.6 (4 October 2020)</h3>
<p>This release adds support for PostgreSQL 13.</p>
<p>It includes improvements to the JDBC 4.0 <code>java.sql.SQLXML</code> API that first became available in 1.5.1, an update of the ISO SQL/XML examples based on the Saxon product to Saxon 10 (which now includes support for XML Query higher-order functions in the freely-licensed Saxon-HE), some improvements to internals, and a number of bug fixes.</p><section>
<h4><a name="Version_compatibility"></a>Version compatibility</h4>
<p>PL/Java 1.5.6 can be built against recent PostgreSQL versions including 13, and older ones back to 8.2, using Java SE 8 or later. The source code avoids features newer than Java 6, so building with Java 7 or 6 should also be possible, but is no longer routinely tested. The Java version used at runtime does not have to be the same version used for building. PL/Java itself can run on any Java version 6 or later if built with Java 11 or earlier; it can run on Java 7 or later if built with Java 12 or later. PL/Java functions can be written for, and use features of, whatever Java version will be loaded at run time. See <a href="build/versions.html">version compatibility</a> for more detail.</p>
<p>PL/Java 1.5.6 cannot be built with Java 15 or later, as the Nashorn JavaScript engine used in the build process no longer ships with Java 15. It can be built with <a class="externalLink" href="https://www.graalvm.org/">GraalVM</a>, if <code>-Dpolyglot.js.nashorn-compat</code> is added to the <code>mvn</code> command line. It will run on Java 15 if built with an earlier JDK or with Graal.</p>
<p>When used with GraalVM as the runtime VM, PL/Java functions can use Graal&#x2019;s &#x201c;polyglot&#x201d; capabilities to execute code in any other language available on GraalVM. In this release, it is not yet possible to directly declare a function in a language other than Java.</p></section><section>
<h4><a name="Changes"></a>Changes</h4><section>
<h5><a name="Improvements_to_the_java.sql.SQLXML_type"></a>Improvements to the <code>java.sql.SQLXML</code> type</h5>
<p>Additions to the <code>Adjusting.XML</code> API support <a href="use/sqlxml.html#Additional_adjustments_in_recent_Java_versions">limiting resource usage</a> in XML processing, controlling <a href="use/sqlxml.html#Supplying_a_SAX_or_DOM_EntityResolver_or_Schema">resolution</a> of external documents and resources, <a href="use/sqlxml.html#Validation_against_a_schema">validation against a schema</a>, and integration of an <a href="use/sqlxml.html#Using_XML_Catalogs_when_running_on_Java_9_or_later">XML catalog</a> to locally satisfy requests for external documents.</p>
<p>Corrections and new documentation of <a href="use/sqlxml.html#Effect_on_parsing_of_whitespace">whitespace handling</a> in XML values of <code>CONTENT</code> form, and implementation <a href="use/sqlxml.html#Known_limitations">limitations</a>.</p></section><section>
<h5><a name="Improvements_to_the_Saxon-based_ISO_SQL.2FXML_example_functions"></a>Improvements to the Saxon-based ISO SQL/XML example functions</h5>
<p>Updated the dependency for these optional examples to Saxon 10. Probably the most significant of the <a class="externalLink" href="https://www.saxonica.com/html/documentation/changes/v10/installation.html">Saxon 10 changes</a>, for PostgreSQL&#x2019;s purposes, will be that the XQuery <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#id-higher-order-function-feature">higher-order function feature</a> is now included in the freely-licensed Saxon-HE, so that it is now possible without cost to integrate a modern XQuery 3.1 implementation that is lacking only the <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#id-schema-aware-feature">schema-aware feature</a> and the <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#id-typed-data-feature">typed data feature</a> (for those, the paid Saxon-EE product is needed), and the <a class="externalLink" href="https://www.w3.org/TR/xquery-31/#id-static-typing-feature">static typing feature</a> (which is not in any Saxon edition).</p>
<p>To compensate for delivering the higher-order function support in -HE, Saxonica moved certain optimizations to -EE. This seems a justifiable trade, as it is better for development purposes to have the more complete implementation of the language, leaving better optimization to be bought if and when needed.</p>
<p>Thanks to a tip from Saxon&#x2019;s developer, the returning of results to SQL is now done in a way that may incur less copying in some cases.</p></section><section>
<h5><a name="Internals"></a>Internals</h5>
<ul>

<li>Many sources of warnings reported by the Java VM&#x2019;s <code>-Xcheck:jni</code> option have been tracked down, making it practical to use <code>-Xcheck:jni</code> in testing.</li>
<li>Reduced pressure on the garbage collector in management of references to PostgreSQL native state.</li>
</ul></section></section><section>
<h4><a name="Enhancement_requests_addressed"></a>Enhancement requests addressed</h4>
<ul>

<li>Work around PostgreSQL <a class="externalLink" href="https://github.com/tada/pljava/issues/260">API breakage in EnterpriseDB 11</a></li>
</ul></section><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/300">Support of arrays in composite types</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/310">Order-dependent behavior caching array types</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/297">Date conversion errors possible with PostgreSQL 10 on Windows/MSVC</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/282">Build issue with Windows/MinGW-w64</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/280">&#x201c;xmltable&#x201d; with XML output column or parameter</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/274">Google Summer of Code catches 15-year-old PL/Java bug</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/272">Several bugs in SQLXML handling</a></li>
<li>Work around an exception from <code>Reference.clear</code> on OpenJ9 JVM</li>
<li>Bugs in SQL generator when supplying a function parameter name, or the <code>category</code>, <code>delimiter</code>, or <code>storage</code> attribute of a user-defined type.</li>
</ul></section><section>
<h4><a name="Updated_PostgreSQL_APIs_tracked"></a>Updated PostgreSQL APIs tracked</h4>
<ul>

<li>Removal of <code>CREATE EXTENSION ... FROM unpackaged</code></li>
<li><code>numvals</code> in <code>SPITupleTable</code></li>
<li><code>detoast.h</code></li>
<li><code>detoast_external_attr</code></li>
</ul></section><section>
<h4><a name="Credits"></a>Credits</h4>
<p>There is a PL/Java 1.5.6 thanks in part to Christoph Berg, Chapman Flack, Kartik Ohri, original creator Thomas Hallgren, and the many contributors to earlier versions.</p>
<p>The work of Kartik Ohri in summer 2020 was supported by Google Summer of Code.</p></section></section><section>
<h3><a name="PL.2FJava_1.5.5_.284_November_2019.29"></a>PL/Java 1.5.5 (4 November 2019)</h3>
<p>This bug-fix release fixes runtime issues reported in 32-bit <code>i386</code> builds, some of which would not affect a more common 64-bit architecture, but some of which could under the wrong circumstances, so this release should be used in preference to 1.5.4 or 1.5.3 on any architecture.</p>
<p>It is featurewise identical to 1.5.4, so those release notes, below, should be consulted for the details of user-visible changes.</p>
<p>Thanks to Christoph Berg for the <code>i386</code> testing that exposed these issues.</p><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/246">32bit i386 segfault</a></li>
</ul></section></section><section>
<h3><a name="PL.2FJava_1.5.4_.2829_October_2019.29"></a>PL/Java 1.5.4 (29 October 2019)</h3>
<p>This minor release fixes a build issue reported with Java 11, and adds support for building with Java 13. Issues with building the javadocs in later Java versions are resolved. A work-in-progress feature that can <a href="use/xmlview.html">apply the SQLXML API to other tree-structured data types</a> is introduced.</p>
<p>Documentation updates include coverage of <a href="install/appcds.html">changes to Application Class Data Sharing</a> in recent Hotspot versions, and ahead-of-time compilation using <a href="install/vmoptions.html#a-XX:AOTLibrary">jaotc</a>.</p>
<p>Otherwise, the release notes for 1.5.3, below, should be consulted for the details of recent user-visible changes.</p><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/235">Build failure with Java 11 and &#x2013;release</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/236">Build with Java 13</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/239">Javadoc build fails in Java 11+</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/241">Javadoc build fails in Java 13</a></li>
</ul></section></section><section>
<h3><a name="PL.2FJava_1.5.3_.284_October_2019.29"></a>PL/Java 1.5.3 (4 October 2019)</h3>
<p>This release adds support for PostgreSQL 12, and removes the former requirement to build with a Java release earlier than 9.</p>
<p>It includes a rework of of threading and resource management, improvements to the JDBC 4.0 <code>java.sql.SQLXML</code> API that first became available in 1.5.1, and a substantially usable example providing the functionality of ISO SQL <code>XMLEXISTS</code>, <code>XMLQUERY</code>, <code>XMLTABLE</code>, <code>XMLCAST</code>, <code>LIKE_REGEX</code>, <code>OCCURRENCES_REGEX</code>, <code>POSITION_REGEX</code>, <code>SUBSTRING_REGEX</code>, and <code>TRANSLATE_REGEX</code>. Some bugs are fixed.</p><section>
<h4><a name="Version_compatibility"></a>Version compatibility</h4>
<p>PL/Java 1.5.3 can be built against recent PostgreSQL versions including 12, and older ones back to 8.2, using Java SE 8 or later. The source code avoids features newer than Java 6, so building with Java 7 or 6 should also be possible, but is no longer routinely tested. The Java version used at runtime does not have to be the same version used for building. PL/Java itself can run on any Java version 6 or later if built with Java 11 or earlier; it can run on Java 7 or later if built with Java 12. PL/Java functions can be written for, and use features of, whatever Java version will be loaded at run time. See <a href="build/versions.html">version compatibility</a> for more detail.</p>
<p>When used with <a class="externalLink" href="https://www.graalvm.org/">GraalVM</a> as the runtime VM, PL/Java functions can use its &#x201c;polyglot&#x201d; capabilities to execute code in any other language available on GraalVM. In this release, it is not yet possible to directly declare a function in a language other than Java.</p></section><section>
<h4><a name="Changes"></a>Changes</h4><section>
<h5><a name="Threading.2Fsynchronization.2C_finalizers.2C_and_new_configuration_variable"></a>Threading/synchronization, finalizers, and new configuration variable</h5>
<p>Java is multithreaded while PostgreSQL is not, requiring ways to prevent Java threads from entering PostgreSQL at the wrong times, while cleaning up native resources in PostgreSQL when PL/Java references are released, and <i>vice versa</i>.</p>
<p>PL/Java has historically used an assortment of approaches including Java object finalizers, which have long been deprecated informally, and formally since Java 9. Finalizers enter PostgreSQL from a thread of their own, and the synchronization approach used in PL/Java 1.5.2 and earlier has been associated with occasional hangs at backend exit when using an OpenJ9 JVM at runtime.</p>
<p>A redesigned approach using a new <code>DualState</code> class was introduced in 1.5.1, at first only used in implementing the <code>java.sql.SQLXML</code> type, a newly-added feature. In 1.5.3, other approaches used in the rest of PL/Java&#x2019;s code base are migrated to use <code>DualState</code> also, and all uses of the deprecated Java object finalizers have been retired. With the new techniques, the former occasional OpenJ9 hangs have not been observed.</p>
<p>This represents the most invasive change to PL/Java&#x2019;s thread synchronization in many years, so it may be worthwhile to reserve extra time for testing applications.</p>
<p>A new <a href="use/variables.html">configuration variable</a>, <code>pljava.java_thread_pg_entry</code>, allows adjusting the thread policy. The default setting, <code>allow</code>, preserves PL/Java&#x2019;s former behavior, allowing Java threads entry into PostgreSQL one at a time, only when any thread already in PG code has entered or returned to Java.</p>
<p>With object finalizers no longer used, PL/Java itself does not need the <code>allow</code> mode, but there may be application code that does. Application code can be tested by setting the <code>error</code> mode, which will raise an error for any attempted entry to PG from a thread other than the original thread that launched PL/Java. If an application runs in <code>error</code> mode with no errors, it can also be run in <code>block</code> mode, which may be more efficient, as it eliminates many locking operations that happen in <code>allow</code> or <code>error</code> mode. However, if <code>block</code> mode is used with an application that has not been fully tested in <code>error</code> mode first, and the application does attempt to enter PostgreSQL from a Java thread other than the initial one, the result can be blocked threads or a deadlocked backend that has to be killed.</p>
<p>A JMX management client like <code>JConsole</code> or <code>jvisualvm</code> can identify threads that are blocked, if needed. The new <code>DualState</code> class also offers some statistics that can be viewed in <code>JConsole</code>, or <code>jvisualvm</code> with the <code>VisualVM-MBeans</code> plugin.</p></section><section>
<h5><a name="Improvements_to_the_java.sql.SQLXML_type"></a>Improvements to the <code>java.sql.SQLXML</code> type</h5>
<p>Support for this JDBC 4.0 type was added in PL/Java 1.5.1. Release 1.5.3 includes the following improvements:</p>
<ul>

<li>A new <a href="use/sqlxml.html#Extended_API_to_configure_XML_parsers">&#x201c;Adjusting&#x201d; API</a> exposes configuration settings for Java XML parsers that may be created internally during operations on <code>SQLXML</code> instances. That allows the default settings to restrict certain XML parser features as advocated by the <a class="externalLink" href="https://www.owasp.org/index.php/About_The_Open_Web_Application_Security_Project">Open Web Application Security Project</a> when XML content may be coming from untrusted sources, with a simple API for relaxing those restrictions when appropriate for XML content from a known source.</li>
<li>It is now possible for a PL/Java function to return, pass into a <code>PreparedStatement</code>, etc., an <code>SQLXML</code> instance that PL/Java did not create. For example, a PL/Java function could use another database&#x2019;s JDBC driver to obtain a <code>SQLXML</code> value from that database, and use that as its own return value. Transparently, the content is copied to a PL/Java <code>SQLXML</code> instance. The copy can also be done explicitly, allowing the &#x201c;Adjusting&#x201d; API to be used if the default XML parser restrictions should be relaxed.</li>
<li>Behavior when the server encoding is not UTF-8, or when it is not an IANA-registered encoding (even if Java has a codec for it), has been improved.</li>
</ul></section><section>
<h5><a name="Improvements_to_the_Saxon-based_ISO_SQL.2FXML_example_functions"></a>Improvements to the Saxon-based ISO SQL/XML example functions</h5>
<p>Since PL/Java 1.5.1, the supplied examples have included a not-built-by-default <a href="examples/saxon.html">example supplying ISO SQL/XML features missing from core PostgreSQL</a>. It is not built by default because it raises the minimum Java version to 8, and brings in the Saxon-HE XML-processing library.</p>
<p>In 1.5.3, the example now provides versions of the ISO SQL <code>XMLEXISTS</code>, <code>XMLQUERY</code>, <code>XMLTABLE</code>, and <code>XMLCAST</code> functions based on the W3C XQuery language as ISO SQL specifies (while PostgreSQL has an &#x201c;XMLTABLE&#x201d; function since release 10 and &#x201c;XMLEXISTS&#x201d; since 9.1, they have <a class="externalLink" href="https://www.postgresql.org/docs/12/xml-limits-conformance.html">numerous limitations</a> inherited from a library that does not support XQuery, and additional peculiarities prior to PostgreSQL 12), and the ISO SQL <code>LIKE_REGEX</code>, <code>OCCURRENCES_REGEX</code>, <code>POSITION_REGEX</code>, <code>SUBSTRING_REGEX</code>, and <code>TRANSLATE_REGEX</code> functions that apply XQuery regular expressions. It also includes the <code>XMLTEXT</code> function, which is rather trivial, but also missing from core PostgreSQL, and supplied here for completeness.</p>
<p>As plain user-defined functions without special treatment in PostgreSQL&#x2019;s SQL parser, these functions cannot be used with the exact syntax specified in ISO SQL, but require simple rewriting into equivalent forms that are valid ordinary PostgreSQL function calls. The rewritten forms are intended to be easy to read and correspond closely to the ISO syntax.</p>
<p>While still presented as examples and not a full implementation, these functions are now intended to be substantially usable (subject to minor <a href="examples/saxon.html">documented limits</a>), and testing and reports of shortcomings are welcome.</p></section><section>
<h5><a name="ResultSet_holdability_again"></a>ResultSet holdability again</h5>
<p>A <code>ResultSet</code> obtained from a query done in PL/Java would return the value <code>CLOSE_CURSORS_AT_COMMIT</code> to a caller of its <code>getHoldability</code> method, but in reality would become unusable as soon as the PL/Java function creating it returned to PostgreSQL. That was fixed in PL/Java 1.5.1 for a <code>ResultSet</code> obtained from a <code>Statement</code>, but not for one obtained from a <code>PreparedStatement</code>. It now correctly remains usable to the end of the transaction in either case.</p></section><section>
<h5><a name="Savepoint_behavior_at_rollback"></a>Savepoint behavior at rollback</h5>
<p>Per JDBC, a <code>Savepoint</code> still exists after being used in a rollback, and can be used again; the rollback only invalidates any <code>Savepoint</code> that had been created after the one being rolled back. That should be familiar behavior, as it is the same as PostgreSQL&#x2019;s own SQL <code>SAVEPOINT</code> behavior. It is also correct in pgJDBC, which has test coverage to confirm it. PL/Java has been doing it wrong.</p>
<p>In 1.5.3 it now has the JDBC-specified behavior. For compatibility with existing application code, the meaning of the <code>pljava.release_lingering_savepoints</code> <a href="use/variables.html">configuration variable</a> has been adjusted. The setting tells PL/Java what to do if a <code>Savepoint</code> still exists, neither released nor rolled back, at the time a function exits. If <code>on</code>, the savepoint is released (committed); if <code>off</code>, the savepoint is rolled back. A warning is issued in either case.</p>
<p>In an existing function that used savepoints and assumed that a rolled-back savepoint would be no longer live, it will now be normal for such a savepoint to reach the function exit still alive. To recognize this case, PL/Java tracks whether any savepoint has been rolled back at least once. At function exit, any savepoint that has been neither released nor ever rolled back is disposed of according to the <code>release_lingering_savepoints</code> setting and with a warning, as before, but any savepoint that has already been rolled back at least once is simply released, regardless of the variable setting, and without producing a warning.</p></section><section>
<h5><a name="Control_of_function_parameter_names_in_generated_SQL"></a>Control of function parameter names in generated SQL</h5>
<p>When generating the <code>CREATE FUNCTION</code> command in a deployment descriptor according to an annotated Java function, PL/Java ordinarily gives the function parameters names that match their Java names, unquoted. Because PostgreSQL allows named notation when calling a function, the parameter names in its declaration become part of its signature that cannot later be changed without dropping and re-creating the function.</p>
<p>In some cases, explicit control of the SQL parameter names may be wanted, independently of the Java names: to align with an external standard, perhaps, or when either the SQL or the Java name would collide with a reserved word. For that purpose, the (already slightly overloaded) <code>@SQLType</code> annotation now has a <code>name</code> attribute that can specify the SQL name of the annotated parameter.</p></section><section>
<h5><a name="Documentation"></a>Documentation</h5>
<p>The user guide and guide for packagers contained incorrect instructions for using Maven to build a single subproject of PL/Java (such as <code>pljava-api</code> or <code>pljava-examples</code>) instead of the full project. Those have been corrected.</p></section></section><section>
<h4><a name="Enhancement_requests_addressed"></a>Enhancement requests addressed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/212">Allow building with Java releases newer than 8</a></li>
</ul></section><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/209">ResultSet holdability still wrong when using PreparedStatement</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/225">Can&#x2019;t return (or set/update PreparedStatement/ResultSet) non-PL/Java SQLXML object</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/228">JDBC Savepoint behavior</a></li>
<li>Writing <code>SQLXML</code> via StAX when server encoding is not UTF-8</li>
<li>StAX rejecting server encoding if not an IANA-registered encoding</li>
<li>Error handling when PL/Java startup fails (may have been <a class="externalLink" href="https://github.com/tada/pljava/issues/211">issue 211</a>)</li>
<li>SPI connection management for certain set-returning functions</li>
</ul></section><section>
<h4><a name="Updated_PostgreSQL_APIs_tracked"></a>Updated PostgreSQL APIs tracked</h4>
<ul>

<li>Retirement of <code>dynloader.h</code></li>
<li>Retirement of magical Oids</li>
<li>Retirement of <code>nabstime</code></li>
<li>Retirement of <code>pg_attrdef.adsrc</code></li>
<li>Extensible <code>TupleTableSlot</code>s</li>
<li><code>FunctionCallInfoBaseData</code></li>
</ul></section><section>
<h4><a name="Credits"></a>Credits</h4>
<p>There is a PL/Java 1.5.3 thanks in part to Christoph Berg, Chapman Flack, <code>ppKrauss</code>, original creator Thomas Hallgren, and the many contributors to earlier versions.</p></section></section><section>
<h3><a name="PL.2FJava_1.5.2_.285_November_2018.29"></a>PL/Java 1.5.2 (5 November 2018)</h3>
<p>A pure bug-fix release, correcting a regression in 1.5.1 that was not caught in pre-release testing, and could leave <a class="externalLink" href="https://github.com/tada/pljava/issues/199">conversions between PostgreSQL <code>date</code> and <code>java.sql.Date</code></a> off by one day in certain timezones and times of the year.</p>
<p>1.5.1 added support for the newer <code>java.time</code> classes from JSR 310 / JDBC 4.2, which are <a href="use/datetime.html">recommended as superior alternatives</a> to the older conversions involving <code>java.sql.Date</code> and related classes. The new versions are superior in part because they do not have hidden timezone dependencies.</p>
<p>However, the change to the historical <code>java.sql.Date</code> conversion behavior was inadvertent, and is fixed in this release.</p><section>
<h4><a name="Open_issues_with_date.2Ftime.2Ftimestamp_conversions"></a>Open issues with date/time/timestamp conversions</h4>
<p>During preparation of this release, other issues of longer standing were also uncovered in the legacy conversions between PG <code>date</code>, <code>time</code>, and <code>timestamp</code> classes and the <code>java.sql</code> types. They are detailed in <a class="externalLink" href="https://github.com/tada/pljava/issues/200">issue #200</a>. Because they are not regressions but long-established behavior, they are left untouched in this release, and will be fixed in a future release.</p>
<p>The Java 8 <code>java.time</code> conversions are free of these issues as well.</p></section></section><section>
<h3><a name="PL.2FJava_1.5.1_.2817_October_2018.29"></a>PL/Java 1.5.1 (17 October 2018)</h3>
<p>This release adds support for PostgreSQL 9.6, 10, and 11, and plays more nicely with <code>pg_upgrade</code>. If a PostgreSQL installation is to be upgraded using <code>pg_upgrade</code>, and is running a version of PL/Java before 1.5.1, the PL/Java version should first be upgraded in the running PostgreSQL version, and then the PostgreSQL <code>pg_upgrade</code> can be done.</p>
<p>The documentation is expanded on the topic of shared-memory precompiled class cache features, which can substantially improve JVM startup time and memory footprint, and are now available across Oracle Java, OpenJDK with Hotspot, and OpenJDK with OpenJ9. When running on OpenJ9, PL/Java cooperates with the JVM to include even the application&#x2019;s classes (those loaded with <code>install_jar</code>) in the shared cache, something not yet possible with Hotspot. While the advanced sharing feature in Oracle Java is still subject to a commercial licensing encumbrance, the equivalent (or superior, with OpenJ9) features in OpenJDK are not encumbered.</p>
<p>Significant new functionality includes new datatype mapping support: SQL <code>date</code>, <code>time</code>, and <code>timestamp</code> values can be mapped to the new Java classes of the <code>java.time</code> package in Java 8 and later (JSR 310 / JDBC 4.2), which are much more faithful representations of the values in SQL. Values of <code>xml</code> type can be manipulated efficiently using the JDBC 4.0 <code>SQLXML</code> API, supporting several different APIs for XML processing in Java.</p>
<p>For Java code that does not use the new date/time classes in the <code>java.time</code> package, some minor conversion inaccuracies (less than two seconds) in the older mapping to <code>java.sql.Timestamp</code> have been corrected.</p>
<p>Queries from PL/Java code now produce <code>ResultSet</code>s that are usable to the end of the containing transaction, as they had already been claiming to be.</p>
<p>With PostgreSQL 9.6 support comes the ability to declare functions <code>PARALLEL { UNSAFE | RESTRICTED | SAFE }</code>, and with PG 10 support, transition tables are available to triggers.</p><section>
<h4><a name="Security"></a>Security</h4><section>
<h5><a name="Schema-qualification"></a>Schema-qualification</h5>
<p>PL/Java now more consistently schema-qualifies objects in queries and DDL it generates internally, as a measure of defense-in-depth in case the database it is installed in has not been <a class="externalLink" href="https://wiki.postgresql.org/wiki/A_Guide_to_CVE-2018-1058:_Protect_Your_Search_Path#Next_Steps:_How_Can_I_Protect_My_Databases.3F">protected</a> from <a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1058">CVE-2018-1058</a>.</p>
<p><i>No schema-qualification work has been done on the example code.</i> If the examples jar will be installed, it should be in a database that <a class="externalLink" href="https://wiki.postgresql.org/wiki/A_Guide_to_CVE-2018-1058:_Protect_Your_Search_Path#Next_Steps:_How_Can_I_Protect_My_Databases.3F">the recommended steps have been taken to secure</a>.</p></section><section>
<h5><a name="Some_large-object_code_removed"></a>Some large-object code removed</h5>
<p>1.5.1 removes the code at issue in <a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0768">CVE-2016-0768</a>, which pertained to PostgreSQL large objects, but had never been documented or exposed as API.</p>
<p>This is not expected to break any existing code at all, based on further review showing the code in question had also been simply broken, since 2006, with no reported issues in that time. That discovery would support an argument for downgrading the severity of the reported vulnerability, but with no need to keep that code around, it is more satisfying to remove it entirely.</p>
<p>Developers wishing to manipulate large objects in PL/Java are able to do so using the SPI JDBC interface and the large-object SQL functions already available in every PostgreSQL version PL/Java currently supports.</p></section></section><section>
<h4><a name="Version_compatibility"></a>Version compatibility</h4>
<p>PL/Java 1.5.1 can be built against recent PostgreSQL versions including 11, and older ones back to 8.2, using Java SE 8, 7, or 6. It can <i>run</i> using newer Java versions including Java 11. PL/Java functions can be written for, and use features of, the Java version loaded at run time. See <a href="build/versions.html">version compatibility</a> for more detail.</p>
<p>OpenJDK is supported, and can be downloaded in versions using the Hotspot or the OpenJ9 JVM. Features of modern Java VMs can drastically reduce memory footprint and startup time, in particular class-data sharing. Several choices of Java runtime now offer such features: Oracle Java has a simple class data sharing feature for the JVM itself, freely usable in all supported versions, and an &#x201c;application class data sharing&#x201d; feature in Java 8 and later that can also share the internal classes of PL/Java, but is a commercial feature requiring a license from Oracle. As of Java 10, the same application class sharing feature is present in OpenJDK/Hotspot, where it is freely usable without an additional license. OpenJDK/OpenJ9 includes a different, and very sophisticated, class sharing feature, freely usable from Java 8 onward. More on these features can be found <a href="install/vmoptions.html">in the installation docs</a>.</p></section><section>
<h4><a name="Changes"></a>Changes</h4><section>
<h5><a name="Typing_of_parameters_in_prepared_statements"></a>Typing of parameters in prepared statements</h5>
<p>PL/Java currently does not determine the necessary types of <code>PreparedStatement</code> parameters from the results of PostgreSQL&#x2019;s own type analysis of the query (as a network client would, when using PostgreSQL&#x2019;s &#x201c;extended query&#x201d; protocol). PostgreSQL added the means to do so in SPI only in PostgreSQL 9.0, and a future PL/Java major release should use it. However, this release does make two small changes to the current behavior.</p>
<p>Without the query analysis results from PostgreSQL, PL/Java tries to type the prepared-statement parameters based on the types of values supplied by the application Java code. It now has two additional ways to do so:</p>
<ul>

<li>

<p>If Java code supplies a Java user-defined type (UDT)&#x2014;that is, an object implementing the <code>SQLData</code> interface&#x2014;PL/Java will now call the <code>SQLData</code> method <code>getSQLTypeName</code> on that object and use the result to pin down the PostgreSQL type of the parameter. Existing code should already provide this method, but could, in the past, have returned a bogus result without detection, as PL/Java did not use it.</p>
</li>
<li>

<p>Java code can use the three-argument form of <code>setNull</code> to specify the exact PostgreSQL type for a parameter, and then another method can be used to supply a non-null value for it. If the following non-null value has a default mapping to a different PostgreSQL type, in most cases it will overwrite the type supplied with <code>setNull</code> and re-plan the query. That was PL/Java&#x2019;s existing behavior, and was not changed for this minor release. However, the new types introduced in this release&#x2014;the <code>java.time</code> types and <code>SQLXML</code>&#x2014;behave in the way that should become universal in a future major release: the already-supplied PostgreSQL type will be respected, and PL/Java will try to find a usable coercion to it.</p>
</li>
</ul></section><section>
<h5><a name="Inaccuracies_converting_TIMESTAMP_and_TIMESTAMPTZ"></a>Inaccuracies converting TIMESTAMP and TIMESTAMPTZ</h5>
<p>When converting between PostgreSQL values of <code>timestamp</code> or <code>timestamptz</code> type and the pre-Java 8 original JDBC type <code>java.sql.Timestamp</code>, there were cases where values earlier than 1 January 2000 would produce exceptions rather than converting successfully. Those have been fixed.</p>
<p>Also, converting in the other direction, from <code>java.sql.Timestamp</code> to a PostgreSQL timestamp, an error of up to 1.998 seconds (averaging 0.999) could be introduced.</p>
<p>That error has been corrected. If an application has stored Java <code>Timestamp</code>s and corresponding SQL <code>timestamp</code>s generated in the past and requires them to match, it could be affected by this change.</p></section><section>
<h5><a name="New_date.2Ftime.2Ftimestamp_API_in_Java_8_java.time_package"></a>New date/time/timestamp API in Java 8 <code>java.time</code> package</h5>
<p>The old, and still default, mappings in JDBC from the SQL <code>date</code>, <code>time</code>, and <code>timestamp</code> types to <code>java.sql.Date</code>, <code>java.sql.Time</code>, and <code>java.sql.Timestamp</code>, were never well suited to represent the PostgreSQL data types. The <code>Time</code> and <code>Timestamp</code> classes were used to map both the with-timezone and without-timezone variants of the corresponding SQL types and, clearly, could not represent both equally well. These Java classes all contain timezone dependencies, requiring the conversion to involve timezone calculations even when converting non-zoned SQL types, and making the conversion results for non-zoned types implicitly depend on the current PostgreSQL session timezone setting.</p>
<p>Applications are strongly encouraged to adopt Java 8 as a minimum language version and use the new-in-Java-8 types in the <code>java.time</code> package, which eliminate those problems and map the SQL types much more faithfully. For PL/Java function parameters and returns, the class in the method declaration can simply be changed. For retrieving date/time/timestamp values from a <code>ResultSet</code> or <code>SQLInput</code> object, use the variants of <code>getObject</code> / <code>readObject</code> that take a <code>Class&lt;?&gt;</code> parameter. The class to use is:</p>
<table border="0" class="bodyTable"><caption>Correspondence of PostgreSQL date/time types and Java 8 <code>java.time</code> classes</caption>
<thead>

<tr class="a">
<th align="right"> PostgreSQL type </th>
<th align="left"> <code>java.time</code> class </th></tr>
</thead><tbody>

<tr class="b">
<td align="right"><code>date</code></td>
<td align="left"><code>LocalDate</code></td></tr>
<tr class="a">
<td align="right"><code>time without time zone</code></td>
<td align="left"><code>LocalTime</code></td></tr>
<tr class="b">
<td align="right"><code>time with time zone</code></td>
<td align="left"><code>OffsetTime</code></td></tr>
<tr class="a">
<td align="right"><code>timestamp without time zone</code></td>
<td align="left"><code>LocalDateTime</code></td></tr>
<tr class="b">
<td align="right"><code>timestamp with time zone</code></td>
<td align="left"><code>OffsetDateTime</code></td></tr>
</tbody>
</table>
<p>Details on these mappings are <a href="use/datetime.html">added to the documentation</a>.</p></section><section>
<h5><a name="Newly_supported_java.sql.SQLXML_type"></a>Newly supported <code>java.sql.SQLXML</code> type</h5>
<p>PL/Java has not, until now, supported the JDBC 4.0 <code>SQLXML</code> type. PL/Java functions have been able to work with PostgreSQL XML values by mapping them as Java <code>String</code>, but that conversion could introduce character encoding issues outside the control of the XML APIs, and also has memory implications if an application stores, or generates in queries, large XML values. Even if the processing to be done in the application could be structured to run in constant bounded memory while streaming through the XML, a conversion to <code>String</code> requires the whole, uncompressed, character-serialized value to be brought into the Java heap at once, and any heap-size tuning has to account for that worst-case size. The <code>java.sql.SQLXML</code> API solves those problems by allowing XML manipulation with any of several Java XML APIs with the data remaining in PostgreSQL native memory, never brought fully into the Java heap unless that is what the application does. Heap sizing can be based on the just the application&#x2019;s processing needs.</p>
<p>The <code>SQLXML</code> type can take the place of <code>String</code> in PL/Java function parameters and returns simply by changing their declarations from <code>String</code> to <code>SQLXML</code>. When retrieving XML values from <code>ResultSet</code> or <code>SQLInput</code> objects, the legacy <code>getObject / readObject</code> methods will continue to return <code>String</code> for existing application compatibility, so the specific <code>getSQLXML / readSQLXML</code> methods, or the forms of <code>getObject / readObject</code> with a <code>Class&lt;?&gt;</code> parameter and passing <code>SQLXML.class</code>, must be used. A <a href="use/sqlxml.html">documentation page</a> has been added, and the <a href="pljava-examples/apidocs/index.html?org/postgresql/pljava/example/annotation/PassXML.html">PassXML example</a> illustrates use of the API.</p>
<p>A <a href="examples/saxon.html">not-built-by-default new example</a> (because it depends on Java 8 and the Saxon-HE XML-processing library) provides a partial implementation of true <code>XMLQUERY</code> and <code>XMLTABLE</code> functions for PostgreSQL, using the standard-specified XML Query language rather than the XPath 1.0 of the native PostgreSQL functions.</p></section><section>
<h5><a name="New_Java_property_exposes_the_PostgreSQL_server_character-set_encoding"></a>New Java property exposes the PostgreSQL server character-set encoding</h5>
<p>A Java system property, <code>org.postgresql.server.encoding</code>, is set to the canonical name of a supported Java <code>Charset</code> that corresponds to PostgreSQL&#x2019;s <code>server_encoding</code> setting, if one can be found. If the server encoding&#x2019;s name is not recognized as any known Java <code>Charset</code>, this property will be unset, and some functionality, such as the <code>SQLXML</code> API, may be limited. If a Java <code>Charset</code> does exist (or is made available through a <code>CharsetProvider</code>) that does match the PostgreSQL server encoding, but is not automatically selected because of a naming mismatch, the <code>org.postgresql.server.encoding</code> property can be set (with a <code>-D</code> in <code>pljava.vmoptions</code>) to select it by name.</p></section><section>
<h5><a name="ResultSet_holdability"></a>ResultSet holdability</h5>
<p>A <code>ResultSet</code> obtained from a query done in PL/Java would return the value <code>CLOSE_CURSORS_AT_COMMIT</code> to a caller of its <code>getHoldability</code> method, but in reality would become unusable as soon as the PL/Java function creating it returned to PostgreSQL. It now remains usable to the end of the transaction, as claimed.</p></section><section>
<h5><a name="PostgreSQL_9.6_and_parallel_query"></a>PostgreSQL 9.6 and parallel query</h5>
<p>A function in PL/Java can now be <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/package-summary.html#package_description">annotated</a> <code>parallel={UNSAFE | RESTRICTED | SAFE}</code>, with <code>UNSAFE</code> the default. A new <a href="use/parallel.html">user guide section</a> explains the possibilities and tradeoffs. (Good cases for marking a PL/Java function <code>SAFE</code> may be rare, as pushing such a function into multiple background processes will require them all to start JVMs. But if a practical application arises, PostgreSQL&#x2019;s <code>parallel_setup_cost</code> can be tuned to help the planner make good plans.)</p>
<p>Although <code>RESTRICTED</code> and <code>SAFE</code> Java functions work in simple tests, there has been no exhaustive audit of the code to ensure that PL/Java&#x2019;s internal workings never violate the behavior constraints on such functions. The support should be considered experimental, and could be a fruitful area for beta testing.</p></section><section>
<h5><a name="Tuple_counts_widened_to_64_bits_with_PostgreSQL_9.6"></a>Tuple counts widened to 64 bits with PostgreSQL 9.6</h5>
<p>To accommodate the possibility of more than two billion tuples in a single operation, the SPI implementation of the JDBC <code>Statement</code> interface now provides the JDK 8-specified <code>executeLargeBatch</code> and <code>getLargeUpdateCount</code> methods defined to return <code>long</code> counts. The original <code>executeBatch</code> and <code>getUpdateCount</code> methods remain but, obviously, cannot return counts that exceed <code>INT_MAX</code>. In case the count is too large, <code>getUpdateCount</code> will throw an <code>ArithmeticException</code>; <code>executeBatch</code> will store <code>SUCCESS_NO_INFO</code> for any statement in the batch that affected too many tuples to report.</p>
<p>For now, a <code>ResultSetProvider</code> cannot be used to return more than <code>INT_MAX</code> tuples, but will check that condition and throw an error to ensure predictable behavior.</p></section><section>
<h5><a name="pg_upgrade"></a><code>pg_upgrade</code></h5>
<p>PL/Java should be upgraded to 1.5.1 in a database cluster, before that cluster is binary-upgraded to a newer PostgreSQL version using <code>pg_upgrade</code>. A new <a href="install/upgrade.html">Upgrading</a> installation-guide section centralizes information on both upgrading PL/Java in a database, and upgrading a database with PL/Java in it.</p></section><section>
<h5><a name="Suppressing_row_operations_from_triggers"></a>Suppressing row operations from triggers</h5>
<p>In PostgreSQL, a <code>BEFORE ROW</code> trigger is able to allow the proposed row operation, allow it with modified values, or silently suppress the operation for that row. Way back in PL/Java 1.1.0, the way to produce the &#x2018;suppress&#x2019; outcome was for the trigger method to throw an exception. Since PL/Java 1.2.0, however, an exception thrown in a trigger method is used to signal an error to PostgreSQL, and there has not been a way to suppress the row operation.</p>
<p>The <code>TriggerData</code> interface now has a <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/TriggerData.html#suppress"><code>suppress</code></a> method that the trigger can invoke to suppress the operation for the row.</p></section><section>
<h5><a name="Constraint_triggers"></a>Constraint triggers</h5>
<p>New attributes in the <code>@Trigger</code> annotation allow the SQL generator to create constraint triggers (a type of trigger that can be created with SQL since PostgreSQL 9.1). Such triggers will be delivered by the PL/Java runtime (to indicate that a constraint would be violated, a constraint trigger method should throw an informative exception). However, the trigger method will have access, through the <code>TriggerData</code> interface, only to the properties common to ordinary triggers; methods on that interface to retrieve properties specific to constraint triggers have not been added for this release.</p></section><section>
<h5><a name="PostgreSQL_10_and_trigger_transition_tables"></a>PostgreSQL 10 and trigger transition tables</h5>
<p>A trigger <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/package-summary.html#package_description">annotation</a> can now specify <code>tableOld=&quot;</code><i>name1</i><code>&quot;</code> or <code>tableNew=&quot;</code><i>name2</i><code>&quot;</code>, or both, and the PL/Java function servicing the trigger can do SPI JDBC queries and see the transition table(s) under the given name(s). The <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/Triggers.java">triggers example code</a> has been extended with a demonstration.</p></section><section>
<h5><a name="Logging_from_Java"></a>Logging from Java</h5>
<p>The way the Java logging system has historically been plumbed to PostgreSQL&#x2019;s, as described in <a class="externalLink" href="https://github.com/tada/pljava/issues/125">issue 125</a>, can be perplexing both because it is unaffected by later changes to the PostgreSQL settings after PL/Java is loaded in the session, and because it has honored only <code>log_min_messages</code> and ignored <code>client_min_messages</code>. The second part is easy to fix, so in 1.5.1 the threshold where Java discards messages on the fast path is determined by the finer of <code>log_min_messages</code> and <code>client_min_messages</code>.</p></section><section>
<h5><a name="Conveniences_for_downstream_package_maintainers"></a>Conveniences for downstream package maintainers</h5>
<p>The <code>mvn</code> command to build PL/Java will now accept an option to provide a useful default for <code>pljava.libjvm_location</code>, when building a package for a particular software environment where the likely path to Java is known.</p>
<p>The <code>mvn</code> command will also accept an option to specify, by the path to the <code>pg_config</code> executable, the PostgreSQL version to build against, in case multiple versions exist on the build host. This was already possible by manipulating <code>PATH</code> ahead of running <code>mvn</code>, but the option makes it more explicit.</p>
<p>A new <a href="build/package.html">packaging section</a> in the build guide documents those and a number of considerations for making a PL/Java package.</p></section></section><section>
<h4><a name="Enhancement_requests_addressed"></a>Enhancement requests addressed</h4><section>
<h5><a name="In_1.5.1-BETA3"></a>In 1.5.1-BETA3</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/186">Add a ddr.reproducible option to SQL generator</a></li>
</ul></section><section>
<h5><a name="In_1.5.1-BETA2"></a>In 1.5.1-BETA2</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/137">java 8 date/time api</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/138">Annotations don&#x2019;t support CREATE CONSTRAINT TRIGGER</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/pull/153">Let annotations give defaults to row-type parameters</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/pull/159">Improve DDR generator on the dont-repeat-yourself dimension for UDT type mapping</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/pull/171">Support the JDBC 4.0 SQLXML type</a></li>
</ul></section></section><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4><section>
<h5><a name="In_1.5.1-BETA3"></a>In 1.5.1-BETA3</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/179">self-install jar ClassCastException (&#x2026;ConsString to String), some java 6/7 runtimes</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/176">i386 libjvm_location gets mangled as &#x2026;/jre/lib/1/server/libjvm.so</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/178">java.lang.ClassNotFoundException installing examples jar</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/182">Preprocessor errors building on Windows with MSVC</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/185">Saxon example does not build since Saxon 9.9 released</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/177">Segfault in VarlenaWrapper.Input on 32-bit</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/189">Windows: self-install jar silently fails to replace existing files</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/192">ERROR: java.sql.SQLException: <i>some Java class name</i></a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/195">SetOfRecordTest with timestamp column influenced by environment</a></li>
</ul></section><section>
<h5><a name="In_1.5.1-BETA2"></a>In 1.5.1-BETA2</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/134">PostgreSQL 10: SPI_modifytuple failed with SPI_ERROR_UNCONNECTED</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/136">SPIConnection prepareStatement doesn&#x2019;t recognize all parameters</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/142">Ordinary (non-constraint) trigger has no way to suppress operation</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/146">ResultSetHandle and column definition lists</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/149">PreparedStatement doesn&#x2019;t get parameter types from PostgreSQL</a> <i>(partial improvements)</i></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/155">internal JDBC: inaccuracies converting TIMESTAMP and TIMESTAMPTZ</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/157">Missing type mapping for Java return <code>byte[]</code></a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/163">The REMOVE section of DDR is in wrong order for conditionals</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/166">Loading PL/Java reinitializes timeouts in PostgreSQL &gt;= 9.3</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/168">JDBC ResultSet.CLOSE_CURSORS_AT_COMMIT reported, but usable life shorter</a></li>
</ul></section><section>
<h5><a name="In_1.5.1-BETA1"></a>In 1.5.1-BETA1</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/108">Add support for PostgreSQL 9.6</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/115">Clarify documentation of ResultSetProvider</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/117"><code>pg_upgrade</code> (upgrade failure from 9.5 to 9.6)</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/125">Java logging should honor <code>client_min_messages</code> too</a></li>
</ul></section></section><section>
<h4><a name="Updated_PostgreSQL_APIs_tracked"></a>Updated PostgreSQL APIs tracked</h4>
<ul>

<li><code>heap_form_tuple</code></li>
<li>64-bit <code>SPI_processed</code></li>
<li>64-bit <code>Portal-&gt;portalPos</code></li>
<li>64-bit <code>FuncCallContext.call_cntr</code></li>
<li>64-bit <code>SPITupleTable.alloced</code> and <code>.free</code></li>
<li><code>IsBackgroundWorker</code></li>
<li><code>IsBinaryUpgrade</code></li>
<li><code>SPI_register_trigger_data</code></li>
<li><code>SPI</code> without <code>SPI_push</code>/<code>SPI_pop</code></li>
<li><code>AllocSetContextCreate</code></li>
<li><code>DefineCustom...Variable</code> (no <code>GUC_LIST_QUOTE</code> in extensions)</li>
</ul></section><section>
<h4><a name="Credits"></a>Credits</h4>
<p>There is a PL/Java 1.5.1 thanks in part to Christoph Berg, Thom Brown, Luca Ferrari, Chapman Flack, Petr Michalek, Steve Millington, Kenneth Olson, Fabian Zeindl, original creator Thomas Hallgren, and the many contributors to earlier versions.</p></section></section><section>
<h3><a name="PL.2FJava_1.5.0_.2829_March_2016.29"></a>PL/Java 1.5.0 (29 March 2016)</h3>
<p>This, the first PL/Java numbered release since 1.4.3 in 2011, combines compatibility with the latest PostgreSQL and Java versions with modernized build and installation procedures, automatic generation of SQL deployment code from Java annotations, and many significant fixes.</p><section>
<h4><a name="Security"></a>Security</h4>
<p>Several security issues are addressed in this release. Sites already using PL/Java are encouraged to update to 1.5.0. For several of the issues below, practical measures are described to mitigate risk until an update can be completed.</p>
<p><a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0766">CVE-2016-0766</a>, a privilege escalation requiring an authenticated PostgreSQL connection, is closed by installing PL/Java 1.5.0 (including prereleases) or by updating PostgreSQL itself to at least 9.5.1, 9.4.6, 9.3.11, 9.2.15, 9.1.20. Vulnerable systems are only those running both an older PL/Java and an older PostgreSQL.</p>
<p><a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0767">CVE-2016-0767</a>, in which an authenticated PostgreSQL user with USAGE permission on the <code>public</code> schema may alter the <code>public</code> schema classpath, is closed by release 1.5.0 (including prereleases). If updating to 1.5.0 must be delayed, risk can be mitigated by revoking public <code>EXECUTE</code> permission on <code>sqlj.set_classpath</code> and granting it selectively to responsible users or roles.</p>
<p>This release brings a policy change to a more secure-by-default posture, where the ability to create functions in <code>LANGUAGE java</code> is no longer automatically granted to <code>public</code>, but can be selectively granted to roles that will have that responsibility. The change reduces exposure to a known issue present in 1.5.0 and earlier versions, that will be closed in a future release (<a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0768">CVE-2016-0768</a>, see <b>large objects, access control</b> below).</p>
<p>The new policy will be applied in a new installation; permissions will not be changed in an upgrade, but any site can move to this policy, even before updating to 1.5.0, with <code>REVOKE USAGE ON LANGUAGE java FROM public;</code> followed by explicit <code>GRANT</code> commands for the users/roles expected to create Java functions.</p>
<p><a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-2192">CVE-2016-2192</a>, in which an authenticated user can alter type mappings without owning the types involved. Exploitability is limited by other permissions, but if type mapping is a feature being used at a site, one can interfere with proper operation of code that relies on it. A mitigation is simply to <code>REVOKE EXECUTE ... FROM PUBLIC</code> on the <code>sqlj.add_type_mapping</code> and <code>sqlj.drop_type_mapping</code> functions, and grant the privilege only to selected users or roles. As of 1.5.0, these functions require the invoker to be superuser or own the type being mapped.</p></section><section>
<h4><a name="Version_compatibility"></a>Version compatibility</h4>
<p>PL/Java 1.5.0 can be built against recent PostgreSQL versions including 9.5, using Java SE 8, 7, or 6. See <a href="build/versions.html">version compatibility</a> for more detail. OpenJDK is well supported. Support for GCJ has been dropped; features of modern Java VMs that are useful to minimize footprint and startup time, such as class-data sharing, are now more deeply covered <a href="install/vmoptions.html">in the installation docs</a>.</p></section><section>
<h4><a name="Build_procedures"></a>Build procedures</h4>
<p>Since 2013, PL/Java has been hosted <a class="externalLink" href="https://github.com/tada/pljava">on GitHub</a> and built using <a class="externalLink" href="http://maven.apache.org/">Apache Maven</a>. See the new <a href="build/build.html">build instructions</a> for details.</p>
<p>Reported build issues for specific platforms have been resolved, with new platform-specific build documentation for <a href="build/macosx.html">OS X</a>, <a href="build/solaris.html">Solaris</a>, <a href="build/ubuntu.html">Ubuntu</a>, <a href="build/buildmsvc.html">Windows MSVC</a>, and <a href="build/mingw64.html">Windows MinGW-w64</a>.</p>
<p>The build produces a redistributable installation archive usable with the version of PostgreSQL built against and the same operating system, architecture, and linker. The type of archive is <code>jar</code> on all platforms, as all PL/Java installations will have Java available.</p></section><section>
<h4><a name="Installation_procedures"></a>Installation procedures</h4>
<p>The jar produced by the build is executable and will self-extract, consulting <code>pg_config</code> on the destination system to find the correct default locations for the extracted files. Any location can be overridden. (Enhancement requests <a class="externalLink" href="https://github.com/tada/pljava/issues/6">6</a>, <a class="externalLink" href="https://github.com/tada/pljava/issues/9">9</a>)</p>
<p>PL/Java now uses a PostgreSQL configuration variable, <code>pljava.libjvm_location</code>, to find the Java runtime to use, eliminating the past need for highly platform-specific tricks like link-time options or runtime-loader configuration just so that PL/Java could find Java. PostgreSQL configuration variables are now the only form of configuration needed for PL/Java, and the <code>libjvm_location</code> should be the only setting needed if file locations have not been overridden.</p>
<p>In PostgreSQL 9.1 and later, PL/Java can be installed with <code>CREATE EXTENSION pljava</code>. Regardless of PostgreSQL version, installation has been simplified. Former procedures involving <code>Deployer</code> or <code>install.sql</code> are no longer required. Details are in the <a href="install/install.html">new installation instructions</a>.</p><section>
<h5><a name="Schema_migration"></a>Schema migration</h5>
<p>The tables used internally by PL/Java have changed. If PL/Java 1.5.0 is loaded in a database with an existing <code>sqlj</code> schema populated by an earlier PL/Java version (1.3.0 or later), the structure will be updated without data loss (enhancement request <a class="externalLink" href="https://github.com/tada/pljava/issues/12">12</a>). <i>Remember that PL/Java runs independently in each database session where it is in use. Older PL/Java versions active in other sessions can be disrupted by the schema change.</i></p>
<p>A trial installation of PL/Java 1.5.0 can be done in a transaction, and rolled back if desired, leaving the schema as it was. Any concurrent sessions with active older PL/Java versions will not be disrupted by the altered schema as long as the transaction remains open, <i>but they may block for the duration, so such a test transaction should be kept short</i>.</p></section></section><section>
<h4><a name="Changes"></a>Changes</h4><section>
<h5><a name="Behavior_of_readSQL_and_writeSQL_for_base_and_mirror_user-defined_types"></a>Behavior of <code>readSQL</code> and <code>writeSQL</code> for base and mirror user-defined types</h5>
<p>In the course of fixing <a class="externalLink" href="https://github.com/tada/pljava/issues/98">issue #98</a>, the actual behavior of <code>readSQL</code> and <code>writeSQL</code> with base or mirror types, which had not previously been documented, <a href="develop/coercion.html">now is</a>, along with other details of PL/Java&#x2019;s type coercion rules found only in the code. Because machine byte order was responsible for issue #98, it now (a) is selectable, and (b) has different, appropriate, defaults for mirror UDTs (which need to match PostgreSQL&#x2019;s order) and for base UDTs (which must stay big-endian because of how binary <code>COPY</code> is specified). A <a href="use/byteorder.html">new documentation section</a> explains in detail.</p></section><section>
<h5><a name="USAGE_to_PUBLIC_no_longer_default_for_java_language"></a><code>USAGE</code> to <code>PUBLIC</code> no longer default for <code>java</code> language</h5>
<p>Of the two languages installed by PL/Java, functions that declare <code>LANGUAGE javau</code> can be created only by superusers, while those that declare <code>LANGUAGE java</code> can be created by any user or role granted the <code>USAGE</code> privilege on the language.</p>
<p>In the past, the language <code>java</code> has been created with PostgreSQL&#x2019;s default permission granting <code>USAGE</code> to <code>PUBLIC</code>, but PL/Java 1.5.0 leaves the permission to be explicitly granted to those users or roles expected to create Java functions, in keeping with least-privilege principles. See <b>large objects, access control</b> under <b>known issues</b> for background.</p></section><section>
<h5><a name="SQL_generated_by_Java_annotations"></a>SQL generated by Java annotations</h5>
<p>Java code developed for use by PL/Java can carry in-code annotations, used by the Java compiler to generate the SQL commands to declare the new functions, types, triggers, etc. in PostgreSQL (enhancement request <a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=1011112">1011112</a>, though different in implementation). This eliminates the need to have Java code and the corresponding SQL commands developed in parallel, and the class of errors possible when both are not updated together. It also allows compile-time checks that the Java methods or classes being annotated are suitable (correct access modifiers, signatures, etc.) for their declared SQL purposes, rather than discovering such issues only upon loading the code into PostgreSQL and trying to use it.</p>
<p>The Java compiler writes the generated SQL into a &#x201c;deployment descriptor&#x201d; file (<code>pljava.ddr</code> by default), as specified by the SQL/JRT standard. The file can be included in a <code>jar</code> archive with the compiled code, and the commands will be executed by PL/Java when the <code>install_jar</code> function is used to load the jar.</p>
<p>SQL generation is covered in the <a href="use/use.html">updated user documentation</a>, and illustrated in the <a href="use/hello.html">Hello, World example</a> and <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation">several other supplied examples</a>. Reference information is <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/package-summary.html#package_description">in the API documentation</a>. It is currently usable to declare functions, triggers, and user-defined types, both base and composite.</p>
<p>The history of this feature in PL/Java is long, with the first related commits appearing in 2005, six years in advance of an enhancement request for it. It became generally usable in 2013 when building with Java SE 6 or later, using the annotation processing framework Java introduced in that release. 1.5.0 is the first PL/Java numbered release to feature it.</p><section>
<h6><a name="Annotation_keyword_changes"></a>Annotation keyword changes</h6>
<p>If you have been using the SQL generation feature in prerelease <code>git</code> builds of 2013 or later, be aware that some annotation keywords have changed in finalizing the 1.5.0 release. Java code that was compiled using the earlier keywords will continue to work, but will have to be updated before it can be recompiled.</p>
<ul>

<li>For functions: <code>effects=(VOLATILE,STABLE,IMMUTABLE)</code> was formerly <code>type=</code></li>
<li>For functions: <code>type=</code> (<i>an explicit SQL return type for the function</i>) was formerly <code>complexType=</code></li>
<li>For functions: <code>trust=(SANDBOXED,UNSANDBOXED)</code> was formerly <code>(RESTRICTED,UNRESTRICTED)</code></li>
<li>For triggers: <code>called=(BEFORE,AFTER,INSTEAD_OF)</code> was formerly <code>when=</code> and conflicted with the <code>WHEN</code> clause introduced for triggers in PostgreSQL 9.0.</li>
</ul></section></section><section>
<h5><a name="A_jar_may_have_more_than_one_deployment_descriptor"></a>A jar may have more than one deployment descriptor</h5>
<p>PL/Java formerly allowed only one entry in a jar to be a deployment descriptor (that is, a file of SQL commands to be executed upon loading or unloading the jar). The SQL/JRT standard allows multiple entries to be deployment descriptors, executed in the order they are mentioned <i>in the jar manifest</i>, or the reverse of that order when the jar is being unloaded. PL/Java now conforms to the standard.</p>
<p>The behavior is useful during transition to annotation-driven deployment descriptor generation for a project that already has a manually-maintained deployment descriptor. PL/Java&#x2019;s own <code>pljava-examples</code> project is an illustration, in the midst of such a transition itself.</p>
<p>Note the significance placed by SQL/JRT on the order of entries in a jar manifest, whose order is normally <i>not</i> significant according to the Jar File Specification. Care can be needed when manipulating manifests with automated tools that may not preserve order.</p></section><section>
<h5><a name="Conditional_execution_within_deployment_descriptors"></a>Conditional execution within deployment descriptors</h5>
<p>Deployment descriptors have a primitive conditional-execution provision defined in the SQL/JRT standard: commands wrapped in a<br />
<code>BEGIN IMPLEMENTOR</code> <i>identifier</i> construct will only be executed if the <i>identifier</i> is recognized by the SQL/JRT implementation in use. The design makes possible jars that can be installed on different database systems that provide SQL/JRT features, with database-specific commands wrapped in <code>BEGIN IMPLEMENTOR</code> blocks with an <i>identifier</i> specific to the system. By default, PL/Java recognizes the <i>identifier</i> <code>postgresql</code> (matched without regard to case).</p>
<p>PL/Java extends the standard by allowing the PostgreSQL configuration variable <code>pljava.implementors</code> to contain a list of identifiers that will be recognized. SQL code in a deployment descriptor can conditionally add or remove identifiers in this list to influence which subsequent implementor blocks will be executed, giving a still-primitive but more general control structure.</p>
<p>In sufficiently recent PostgreSQL versions, the same effect could be achieved using <code>DO</code> statements and PL/pgSQL control structures, but this facility in PL/Java does not require either to be available.</p></section><section>
<h5><a name="Interaction_with_SET_ROLE_corrected"></a>Interaction with <code>SET ROLE</code> corrected</h5>
<p>PL/Java formerly was aware of the user ID associated with the running session, but not any role ID that user may have acquired with <code>SET ROLE</code>. The result would commonly be failed permission checks made by PL/Java when the session user did not have the needed permission, but had <code>SET ROLE</code> to a role that did. Likewise, within <code>install_jar</code>, PL/Java would execute deployment descriptor commands as the original session user rather than as the user&#x2019;s current role, with permission failures a likely result.</p>
<p>Correcting this issue has changed the PL/Java API, but without a bump of major version because the prior API, while deprecated, is still available.</p>
<ul>

<li><a href="pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#getOuterUserName"><code>getOuterUserName</code></a> and <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#executeAsOuterUserjava.sql.Connectionjava.lang.String"><code>executeAsOuterUser</code></a> are new, and correctly refer to the session user or current role, when active.</li>
<li><a href="pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#getSessionUserName"><code>getSessionUserName</code></a> and <a href="pljava-api/apidocs/index.html?org/postgresql/pljava/Session.html#executeAsSessionUserjava.sql.Connectionjava.lang.String"><code>executeAsSessionUser</code></a> are still present but deprecated, and <i>their semantics are changed</i>. They are now deprecated aliases for the corresponding new methods, which honor the set role. Use cases that genuinely need to refer only to the <i>session</i> user and ignore the role should be rare, and should be discussed on the mailing list or opened as issues.</li>
</ul></section><section>
<h5><a name="Unicode_transparency"></a>Unicode transparency</h5>
<p>Since the resolution of <a class="externalLink" href="https://github.com/tada/pljava/issues/21">bug 21</a>, PL/Java contains a regression test to ensure that character strings passed and returned between PostgreSQL and Java will round-trip without alteration for the full range of Unicode characters, <i>when the database encoding is set to <code>UTF8</code></i>.</p>
<p>More considerations apply when the database encoding is anything other than <code>UTF8</code>, and especially when it is <code>SQL_ASCII</code>. Please see <a href="use/charsets.html">character encoding support</a> for more.</p></section></section><section>
<h4><a name="Enhancement_requests_addressed"></a>Enhancement requests addressed</h4>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=1011112">Use Annotations instead of DDL Manifest</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/9">Installation of pljava on postgresql servers</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/6">Find an alternative way to install the pljava.so in <code>/usr/lib</code></a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/12">Provide database migration</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=1011140">Support types with type modifiers</a> (partial: see <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/IntWithMod.java">example</a>)</li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/102">Build process: accommodate Solaris 10</a></li>
</ul></section><section>
<h4><a name="Bugs_fixed"></a>Bugs fixed</h4><section>
<h5><a name="Since_1.5.0-BETA3"></a>Since 1.5.0-BETA3</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/101">Build process: accept variation in PostgreSQL version string</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/103">Build process: accommodate PostgreSQL built with private libraries</a></li>
<li>Clarified message when <code>CREATE EXTENSION</code> fails because new session needed</li>
<li>Reduced stack usage in SQL generator (small-memory build no longer needs <code>-Xss</code>)</li>
</ul></section><section>
<h5><a name="In_1.5.0-BETA3"></a>In 1.5.0-BETA3</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/98">Bogus mirror-UDT values on little-endian hardware</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/99">Base UDT not registered if first access isn&#x2019;t in/out/send/recv</a></li>
<li><code>TupleDesc</code> leak warnings with composite UDTs</li>
<li>also added regression test from <a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010962">1010962</a> report</li>
</ul></section><section>
<h5><a name="In_1.5.0-BETA2"></a>In 1.5.0-BETA2</h5>
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/issues/92">Generate SQL for trigger function with no parameters</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/94">openssl/ssl.h needed on osx el-capitan (latest 10.11.3)/postgres 9.5</a> (documented)</li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/95">Source location missing for some annotation errors</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/96">OS X El Capitan &#x201c;Java 6&#x201d; dialog when loading &#x2026; Java 8</a></li>
<li>pljava-api jar missing from installation jar</li>
</ul></section><section>
<h5><a name="In_1.5.0-BETA1"></a>In 1.5.0-BETA1</h5>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011119">SPIPreparedStatement.setObject() fails with Types.BIT</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011095">SSLSocketFactory throws IOException on Linux</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011181">PL/Java fails to compile with -Werror=format-security</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011197">PL/Java does not build on POWER 7</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011206">The built in functions do not use the correct error codes</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010962">TupleDesc reference leak</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/4">String conversion to enum fails</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/7">segfault if SETOF RECORD-returning function used without AS at callsite</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/17">pl/java PG9.3 Issue</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/8">No-arg functions unusable: &#x201c;To many parameters - expected 0&#x201d;</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/54">Exceptions in static initializers are masked</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/52">UDT in varlena form breaks if length &gt; 32767</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/21">PL/Java kills unicode?</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/65">Type.c expects pre-8.3 find_coercion_pathway behavior</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/48">Support PostgreSQL 9.5</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/22">pl/java getting a build on MacOSX - PostgreSQL 9.3.2</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/23">build pljava on windows for PostgreSQL 9.2</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/28">Error while installing PL/Java with Postgresql 9.3.4 64 bit on Windows 7 64 bit System</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/63">pljava does not compile on mac osx ver 10.11.1 and postgres 9.4</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/64">pljava does not compile on centos 6.5 and postgres 9.4</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/issues/71">Error installing pljava with Windows 7 64 Bit and Postgres 9.4</a></li>
</ul></section></section><section>
<h4><a name="Updated_PostgreSQL_APIs_tracked"></a>Updated PostgreSQL APIs tracked</h4>
<p>Several APIs within PostgreSQL itself have been added or changed; PL/Java now uses the current versions of these where appropriate:</p>
<ul>

<li><code>find_coercion_pathway</code></li>
<li><code>set_stack_base</code></li>
<li><code>GetOuterUserId</code></li>
<li><code>GetUserNameFromId</code></li>
<li><code>GetUserIdAndSecContext</code></li>
<li><code>pg_attribute_*</code></li>
<li>Large objects: truncate, and 64-bit offsets</li>
</ul></section><section>
<h4><a name="Known_issues_and_areas_for_future_work"></a>Known issues and areas for future work</h4><section>
<h5><a name="Developments_in_PostgreSQL_not_yet_covered"></a>Developments in PostgreSQL not yet covered</h5>
<dl>

<dt>Large objects, access control</dt>
<dd>PL/Java does not yet expose PostgreSQL large objects with a documented, stable API, and the support it does contain was developed against pre-9.0 PostgreSQL versions, where no access control applied to large objects and any object could be accessed by any database user. PL/Java&#x2019;s behavior is proper for PostgreSQL before 9.0, but improper on 9.0+ where it would be expected to honor access controls on large objects (<a class="externalLink" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0768">CVE-2016-0768</a>). This will be corrected in a future release. For this and earlier releases, the recommendation is to selectively grant <code>USAGE</code> on the <code>java</code> language to specific users or roles responsible for creating Java functions; see &#x201c;default <code>USAGE</code> permssion&#x201d; under Changes.</dd>
<dt><code>INSTEAD OF</code> triggers, triggers on <code>TRUNCATE</code></dt>
<dd>These are supported by annotations and the SQL generator, and the runtime will deliver them to the specified method, but the <code>TriggerData</code> interface has no new methods to recognize these cases (that is, no added methods analogous to <code>isFiredAfter</code>, <code>isFiredByDelete</code>). For a method expressly coded to be a <code>TRUNCATE</code> trigger or an <code>INSTEAD OF</code> trigger, that is not a problem, but care should be taken when coding a trigger method to handle more than one type of trigger, or creating triggers of these new types that call a method developed pre-PL/Java-1.5.0. Such a method could be called with a <code>TriggerData</code> argument whose existing <code>isFired...</code> methods all return <code>false</code>, likely to put the method on an unexpected code path.
<p>A later PL/Java version should introduce trigger interfaces that better support such evolution of PostgreSQL in a type-safe way.</p></dd>
<dt>Constraint triggers</dt>
<dd>Constraint trigger syntax is not supported by annotations and the SQL generator. If declared (using hand-written SQL), they will be delivered by the runtime, but without any constraint-trigger-specific information available to the called method.</dd>
<dt>Event triggers</dt>
<dd>Event triggers are not yet supported by annotations or the SQL generator, and will not be delivered by the PL/Java runtime.</dd>
<dt>Range types</dt>
<dd>No predefined mappings for range types are provided.</dd>
<dt><code>PRE_PREPARE</code>, <code>PRE_COMMIT</code>, <code>PARALLEL_ABORT</code>, <code>PARALLEL_PRE_COMMIT</code>, and <code>PARALLEL_COMMIT</code> transaction callbacks, <code>PRE_COMMIT</code> subtransaction callbacks</dt>
<dd>Listeners for these events cannot be registered and the events will not be delivered.</dd>
</dl></section><section>
<h5><a name="Imperfect_integration_with_PostgreSQL_dependency_tracking"></a>Imperfect integration with PostgreSQL dependency tracking</h5>
<p>In a dump/restore, manual intervention can be needed if the users/roles recorded as owners of jars are missing or have been renamed. A current <a class="externalLink" href="http://www.postgresql.org/message-id/56783412.6090005@anastigmatix.net">thread on <code>pgsql-hackers</code></a> should yield a better solution for a future release.</p></section><section>
<h5><a name="Quirk_if_deployment_descriptor_loads_classes_from_same_jar"></a>Quirk if deployment descriptor loads classes from same jar</h5>
<p>The <code>install_jar</code> function installs a jar, optionally reading deployment descriptors from the jar and executing the install actions they contain. It is possible for those actions to load classes from the jar just installed. (This would be unlikely if the install actions are limited to typical setup, function/operator/datatype creation, but likely, if the install actions also include basic function tests, or if the setup requirements are more interesting.)</p>
<p>If, for any class in the jar, the first attempt to load that class is made while resolving a function declared <code>STABLE</code> or <code>IMMUTABLE</code>, a <code>ClassNotFoundException</code> results. The cause is PostgreSQL&#x2019;s normal treatment of a <code>STABLE</code> or <code>IMMUTABLE</code> function, which relies on a snapshot from the start of the <code>install_jar</code> query, when the jar was not yet installed. A workaround is to ensure that the install actions cause each needed class to be loaded, such as by calling a <code>VOLATILE</code> function it supplies, before calling one that is <code>STABLE</code> or <code>IMMUTABLE</code>. (One could even write install actions to declare a needed function <code>VOLATILE</code> before the first call and then redeclare it.)</p>
<p>This issue should be resolved as part of a broader rework of class loading in a future PL/Java release.</p></section><section>
<h5><a name="Partial_implementation_of_JDBC_4_and_later"></a>Partial implementation of JDBC 4 and later</h5>
<p>The changes to make PL/Java build under Java SE 6 and later, with version 4.0 and later of JDBC, involved providing the specified methods so compilation would succeed, with real implementations for some, but for others only stub versions that throw <code>SQLFeatureNotSupportedException</code> if used. Regrettably, there is nothing in the documentation indicating which methods have real implementations and which do not; to create such a list would require an audit of that code. If a method throws the exception when you call it, it&#x2019;s one of the unimplemented ones.</p>
<p>Individual methods may be fleshed out with implementations as use cases arise that demand them, but for a long-term roadmap, it seems more promising to reduce the overhead of maintaining another JDBC implementation by sharing code with <code>pgjdbc</code>, as has been <a class="externalLink" href="http://lists.pgfoundry.org/pipermail/pljava-dev/2015/002370.html">discussed on pljava-dev</a>.</p></section><section>
<h5><a name="Exception_handling_and_logging"></a>Exception handling and logging</h5>
<p>PL/Java does interconvert between PostgreSQL and Java exceptions, but with some loss of fidelity in the two directions. PL/Java code has some access to most fields of a PostgreSQL error data structure, but only through internal PL/Java API that is not expected to remain usable, and code written for PL/Java has never quite had first-class standing in its ability to <i>generate</i> exceptions as information-rich as those from PostgreSQL itself.</p>
<p>PL/Java in some cases generates the <i>categorized <code>SQLException</code>s</i> introduced with JDBC 4.0, and in other cases does not.</p>
<p>This area may see considerable change in a future release. <a class="externalLink" href="https://github.com/tada/pljava/wiki/Thoughts-on-logging">Thoughts on logging</a> is a preview of some of the considerations.</p></section><section>
<h5><a name="Types_with_type_modifiers_and_COPY"></a>Types with type modifiers and <code>COPY</code></h5>
<p>Although it is possible to create a PL/Java user-defined type that accepts a type modifier (see the <a class="externalLink" href="https://github.com/tada/pljava/tree/master//pljava-examples/src/main/java/org/postgresql/pljava/example/annotation/IntWithMod.java">example</a>), such a type will not yet be handled by SQL <code>COPY</code> or any other operation that requires the <code>input</code> or <code>receive</code> function to handle the modifier. This is left for a future release.</p></section></section><section>
<h4><a name="Credits"></a>Credits</h4>
<p>PL/Java 1.5.0 owes its being to original creator Thomas Hallgren and many contributors:</p>
<p>Daniel Blanch Bataller, Peter Brewer, Frank Broda, Chapman Flack, Marty Frasier, Bear Giles, Christian Hammers, Hal Hildebrand, Robert M. Lefkowitz, Eugenie V. Lyzenko, Dos Moonen, Asif Naeem, Kenneth Olson, Johann Oskarsson, Thomas G. Peters, Srivatsan Ramanujam, Igal Sapir, Jeff Shaw, Rakesh Vidyadharan, <code>grunjol</code>, <code>mc-soi</code>.</p>
<p>Periods in PL/Java&#x2019;s development have been sponsored by EnterpriseDB.</p>
<p>In the 1.5.0 release cycle, multiple iterations of testing effort have been generously contributed by Kilobe Systems and by Pegasystems, Inc.</p></section></section><section>
<h3><a name="PL.2FJava_1.4.3_.2815_September_2011.29"></a>PL/Java 1.4.3 (15 September 2011)</h3>
<p>Notable changes in this release:</p>
<ul>

<li>Works with PostgreSQL 9.1</li>
<li>Correctly links against IBM Java.</li>
<li>Reads microseconds correctly in timestamps.</li>
</ul>
<p>Bugs fixed:</p>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010660">Be clear about not building with JDK 1.6</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010970">Does not link with IBM VM</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010971">SPIConnection.getMetaData() is incorrectly documented</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011025">PL/Java 1.4.2 Does not build with x86_64-w64-mingw32</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1011091">PL/Java does not build with PostgreSQL 9.1</a></li>
</ul>
<p>Feature Requests:</p>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=1011092">Allow pg_config to be set externally to the Makefile</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=337&amp;group_id=1000038&amp;aid=1010955">Add option to have pljava.so built with the runtime path of libjvm.so</a></li>
</ul></section><section>
<h3><a name="PL.2FJava_1.4.2_.2811_December_2010.29"></a>PL/Java 1.4.2 (11 December 2010)</h3>
<p>Bugfixes:</p>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010956">Function returning complex objects with POD arrays cause a segfault</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010953">Segfault when assigning an array to ResultSet column</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010482">Embedded array support in returned complex objects</a></li>
</ul></section><section>
<h3><a name="PL.2FJava_1.4.1_.289_December_2010.29"></a>PL/Java 1.4.1 (9 December 2010)</h3>
<p>Note: Does not compile with Java 6.  Use JDK 1.5 or 1.4.</p>
<p>Compiles with PostgreSQL 8.4 and 9.0.</p>
<p>Connection.getCatalog() has been implemented.</p>
<p>Bugfixes:</p>
<ul>

<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010759">Compiling error with postgresql 8.4.1</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010712">org.postgresql.pljava.internal.Portal leak</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010189">build java code with debugging if server has debugging enabled</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010653">Connection.getCatalog() returns null</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010462">VM crash in TransactionListener</a></li>
<li><a class="externalLink" href="https://web.archive.org/web/*/http://pgfoundry.org/tracker/?func=detail&amp;atid=334&amp;group_id=1000038&amp;aid=1010954">Link against wrong library when compiling amd64 code on Solaris</a></li>
</ul>
<p>Other commits:</p>
<p>For a multi-threaded pljava function we need to adjust stack_base_ptr before calling into the backend to avoid stack depth limit exceeded errors.  Previously this was done only on query execution, but we need to do it on iteration of the ResultSet as well.</p>
<p>When creating a variable length data type, the code was directly assigning the varlena header length rather than going through an access macro.  The header format changed for the 8.3 release and this manual coding was not noticed and changed accordingly.  Use SET_VARSIZE to do this correctly.</p>
<p>Handle passed by value data types by reading and writing directly to the Datum rather than dereferencing it.</p>
<p>If the call to a type output function is the first pljava call in a session, we get a crash.  The first pljava call results in a SPI connection being established and torn down.  The type output function was allocating the result in the SPI memory context which gets destroyed prior to returning the data to the caller.  Allocate the result in the correct context to survive function exit.</p>
<p>Clean up a warning about byteasend and bytearecv not having a prototype when building against 9.0 as those declarations are now in a new header file.</p></section><section>
<h3><a name="PL.2FJava_1.4.0_.281_February_2008.29"></a>PL/Java 1.4.0 (1 February 2008)</h3>
<p>Warning! The recent postgresql security releases changed the API of a function that PL/Java uses. The source can be built against either version, but the binaries will only run against the version they were built against. The PL/Java binaries for 1.4.0 have all been built against the latest server releases (which you should be using anyway). If you are using an older you will have to build from source. The binary releases support: 8.3 - All versions. 8.2 - 8.2.6 and up. 8.1 - 8.1.11 and up. 8.0 - 8.0.15 and up.</p></section><section>
<h3><a name="PL.2FJava_1.3.0_.2818_June_2006.29"></a>PL/Java 1.3.0 (18 June 2006)</h3>
<p>This release is about type mapping and the creation of new types in PL/Java. An extensive effort has gone into making the PL/Java type system extremely flexible. Not only can you map arbitrary SQL data types to java classes. You can also create new scalar types completely in Java. Read about the Changes in version 1.3.</p><section>
<h4><a name="Changes"></a>Changes</h4>
<ul>

<li>A much improved type mapping system that will allow you to:
<ul>

<li><a class="externalLink" href="https://github.com/tada/pljava/wiki/Mapping-an-sql-type-to-a-java-class">Map any SQL type to a Java class</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/wiki/Creating-a-scalar-udt-in-java">Create a Scalar UDT in Java</a></li>
<li><a class="externalLink" href="https://github.com/tada/pljava/wiki/Default-type-mapping">Map array and pseudo types</a></li>
</ul>
</li>
</ul>
<ul>

<li>Get the OID for a given relation (<a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1319">feature request 1319</a>)</li>
<li>Jar manifest included in the SQLJ Jar repository (<a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1525">feature request 1525</a>)</li>
</ul></section><section>
<h4><a name="Fixed_bugs"></a>Fixed bugs</h4>
<ul>

<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1531">Reconnect needed for jar manipulation to take effect</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1504">Backends hang with test suite</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1560">Keeps crashing while making a call to a function</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1556">Memory Leak in Statement.executeUpdate</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1506">jarowner incorrect after dump and reload</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1525">Missing JAR manifest</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1547">TZ adjustments for Date are incorrect</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1542">Functions returning sets leaks memory</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1423">drop lib prefix</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1317">&#x201c;oid&#x201d; column is not available in trigger&#x2019;s NEW/OLD ResultSet</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1480">fails to run with GCJ, too</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1558">Compile failure with 8.1.4</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1479">fails to build with GCJ</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1440">Record returning function cannot be called with different structures within one session</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1551">Cannot map function with complex return type to method that uses non primitive arguments</a></li>
<li><a class="externalLink" href="http://web.archive.org/web/20061208113236/http://gborg.postgresql.org/project/pljava/bugs/bugupdate.php?1319">Get OID for given relation</a></li>
</ul></section></section><section>
<h3><a name="PL.2FJava_1.2.0_.2820_Nov_2005.29"></a>PL/Java 1.2.0 (20 Nov 2005)</h3>
<p>The PL/Java 1.2.0 release is primarily targeted at the new PostgreSQL 8.1 but full support for 8.0.x is maintained. New features include support IN/OUT parameters, improved meta-data handling, and better memory management.</p></section><section>
<h3><a name="PL.2FJava_1.1.0_.2814_Apr_2005.29"></a>PL/Java 1.1.0 (14 Apr 2005)</h3>
<p>PL/Java 1.1.0 includes a lot of new features such as <code>DatabaseMetaData</code>, <code>ResultSetMetaData</code>, language handlers for both trusted and untrusted language, additional semantics for functions returning <code>SETOF</code>, and simple ObjectPooling.</p></section><section>
<h3><a name="PL.2FJava_1.0.1_.2807_Feb_2005.29"></a>PL/Java 1.0.1 (07 Feb 2005)</h3>
<p>This release resolves a couple of important security issues. The most important one is perhaps that PL/Java now is a trusted language. See <a class="externalLink" href="https://github.com/tada/pljava/wiki/Security">Security</a> for more info. Filip Hrbek, now member of the PL/Java project, contributed what was needed to make this happen.</p></section><section>
<h3><a name="PL.2FJava_1.0.0_.2823_Jan_2005.29"></a>PL/Java 1.0.0 (23 Jan 2005)</h3>
<p>Today, after a long period of fine tuning, PL/Java 1.0.0 was finally released.</p></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2003&#x2013;2020<a href="http://tada.se/eng/">Tada AB</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
