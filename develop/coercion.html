<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2019-10-03 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>PostgreSQL PL/Java &#x2013; Passing of data types between PostgreSQL and Java</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20191003" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="https://tada.github.io/pljava/" id="bannerLeft" title="PL/Java logo combining the PostgreSQL elephant and a Java bean">
                                                <img src="../images/pljava_logo.jpg" alt="PL/Java logo combining the PostgreSQL elephant and a Java bean" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2019-10-03</span>
                  &nbsp;| <span id="projectVersion">Version: 1.5.3</span>
                      </div>
            <div class="xright">                    <a href="https://github.com/tada/pljava/wiki/" class="externalLink" title="Wiki">Wiki</a>
            |
                        <a href="https://github.com/tada/pljava/issues" class="externalLink" title="Issues">Issues</a>
            |
                        <a href="http://lists.pgfoundry.org/pipermail/pljava-dev/" class="externalLink" title="Mailing list">Mailing list</a>
            |
                        <a href="https://github.com/tada/pljava/tree/master/" class="externalLink" title="Code">Code</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Usage</h5>
                  <ul>
                  <li class="none">
                          <a href="../build/build.html" title="Building PL/Java">Building PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../install/install.html" title="Installing into PostgreSQL">Installing into PostgreSQL</a>
            </li>
                  <li class="none">
                          <a href="../install/upgrade.html" title="Upgrading">Upgrading</a>
            </li>
                  <li class="none">
                          <a href="../build/package.html" title="Packaging PL/Java">Packaging PL/Java</a>
            </li>
                  <li class="none">
                          <a href="../use/use.html" title="User guide">User guide</a>
            </li>
                  <li class="none">
                          <a href="../develop/develop.html" title="Developer notes">Developer notes</a>
            </li>
          </ul>
                       <h5>Release Information</h5>
                  <ul>
                  <li class="none">
                          <a href="../releasenotes.html" title="Release notes">Release notes</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../pljava-api/index.html" title="PL/Java API">PL/Java API</a>
            </li>
                  <li class="none">
                          <a href="../pljava/index.html" title="PL/Java backend Java code">PL/Java backend Java code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-so/index.html" title="PL/Java backend native code">PL/Java backend native code</a>
            </li>
                  <li class="none">
                          <a href="../pljava-deploy/index.html" title="PL/Java Deploy">PL/Java Deploy</a>
            </li>
                  <li class="none">
                          <a href="../pljava-ant/index.html" title="PL/Java Ant tasks">PL/Java Ant tasks</a>
            </li>
                  <li class="none">
                          <a href="../pljava-examples/index.html" title="PL/Java examples">PL/Java examples</a>
            </li>
                  <li class="none">
                          <a href="../pljava-packaging/index.html" title="PL/Java packaging">PL/Java packaging</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="../project-info.html" title="Project Information">Project Information</a>
                  </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <h1>Passing of data types between PostgreSQL and Java</h1>
<p>The wiki documentation for <a class="externalLink" href="https://github.com/tada/pljava/wiki/Default-type-mapping">default type mapping</a> gives a rather high-level view. That seems adequate for most uses (the archives are not full of &#x201c;why on earth did PL/Java do that to my data type?&#x201d; questions), but this page is meant to capture the steps in more detail.</p>
<div class="section">
<h2><a name="Some_preliminaries"></a>Some preliminaries</h2>
<div class="section">
<h3><a name="The_per-schema_class_path"></a>The per-schema class path</h3>
<p>One of the most significant differences between the ISO 9075-13 standard and what PL/Java actually does is in the area of finding and loading classes. In the standard, when a function is declared in SQL, its <tt>external Java reference string</tt> (corresponding to the <tt>AS</tt> clause in PostgreSQL) <i>names the installed jar</i> where the search for the class should begin. The standard also provides an <tt>SQLJ.ALTER_JAVA_PATH</tt> function that gives complete control, based on the jar where a search begins, of which other jars should be searched for dependencies.</p>
<p>By contrast, PL/Java (through and including 1.5) <i>does not</i> include the jar name in <tt>AS</tt> clauses, and provides an <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#setClassPathjava.lang.String20java.lang.String"><tt>SQLJ.SET_CLASSPATH</tt></a> function that can set a distinct class path for any schema in the database. The schema <tt>public</tt> can also have a class path, which becomes the fallback for any search that is not resolved on another schema&#x2019;s class path.</p>
<p>The class named in an SQL function declaration&#x2019;s <tt>AS</tt> clause is looked up on the <i>class path for the schema in which the function is declared</i>, with the <tt>public</tt> schema as fallback.</p></div>
<div class="section">
<h3><a name="The_per-schema_type_map"></a>The per-schema type map</h3>
<p>When PL/Java is used to create user-defined types, there needs to be a way of associating the type name declared in SQL with the Java class that implements it. The most transparent case is a <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">base type</a> (written in PL/Java with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT annotation</a>), which is completely integrated into PostgreSQL&#x2019;s type system and is usable from in or out of Java just like any other PostgreSQL type.</p>
<p>For the other flavors of user-defined type (described below), <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String"><tt>SQLJ.ADD_TYPE_MAPPING</tt></a> (a PL/Java function, not in the standard) must be called to record the connection between the new type&#x2019;s SQL name and the Java class that implements it. The <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT annotation</a> generates a call to this function along with any other SQL commands declaring the type.</p>
<p>What it records is simply the SQL type name as a string, and the Java class name as a string, and these mappings apply database-wide. But internally, PL/Java maintains a type map per schema. Why? (Hint: while it is true that the SQL type names can be schema-qualified, that is not the answer.)</p>
<p>The reason is that the database-wide mappings are from SQL type names to Java class <i>names</i>, and the actual Java class found for a given name can depend on the per-schema class path.</p>
<p>Whenever the rules given below provide for applying the type map, they mean, for parameter and return value conversions done at the invocation of a PL/Java function, the type map for the schema in which the target function is declared and, at other times, the map for the schema in which the innermost executing PL/Java function on the call stack is declared.</p></div>
<div class="section">
<h3><a name="PLJavas_object_system_implemented_in_C"></a>PL/Java&#x2019;s object system implemented in C</h3>
<p>In PL/Java, some behavior is implemented in Java using familiar Java objects, and some is implemented in C with an object-oriented approach using C <tt>struct</tt>s that include and extend each other for &#x2018;classes&#x2019; and their instances, forming a C object hierarchy that inherits ultimately from <tt>PgObject</tt>. Often there is a close relationship between a C &#x2018;class&#x2019; and a Java class of the same name, with instances of one holding references to the other.</p>
<div class="section">
<h4><a name="Types"></a>Types</h4>
<p>The <tt>type</tt> subdirectory in <tt>pljava-so</tt> contains the C sources for a class <tt>Type</tt>, which extends a <tt>TypeClass</tt>, which inherits from <tt>PgObject</tt>. A <tt>TypeClass</tt> is associated with a single Java (primitive or reference) type, and might have only a single <tt>Type</tt> that extends it, associated with a single PostgreSQL type. In that simple case, the singleton <tt>Type</tt> instance can be directly &#x201c;registered&#x201d; in the caches that are keyed by PostgreSQL type oid or by Java type, respectively, by the function <tt>Type_registerType</tt>.</p></div>
<div class="section">
<h4><a name="Type_obtainers"></a>Type obtainers</h4>
<p>It is also possible that a single <tt>TypeClass</tt> can be extended by more than one <tt>Type</tt>, one for each of multiple PostgreSQL types. In that case, an alternate function <tt>Type_registerType2</tt> will cache, not a single already-created <tt>Type</tt> instance, but a <tt>TypeObtainer</tt> function, which can be used to obtain a <tt>Type</tt> extending its associated <tt>TypeClass</tt> and bound to a specific PostgreSQL type.</p>
<p>An obtainer function should not allocate a brand new <tt>Type</tt> on every call, but return an existing <tt>Type</tt> if there already is one for the requested PostgreSQL type. If a <tt>TypeClass</tt> and its associated Java type can only sensibly map a small few PostgreSQL types, it could even be overkill for the obtainer to use a hash map or the like to remember the instances it has returned; it could simply have a few static variables to cache the few instances it will need, and return the right one after comparing its oid argument to a few constants.</p>
<p>The <tt>TypeClass</tt> for <tt>SQLXML</tt> works that way, with an obtainer that will only return a <tt>Type</tt> instance for PostgreSQL <tt>xml</tt>, or for PostgreSQL <tt>text</tt> (in case the Java caller wants to process a text value known to contain XML, or is being used in a PostgreSQL server that was built without the <tt>xml</tt> type).</p>
<p>An alternative to using an obtainer in that case would be for the initialization method of the <tt>TypeClass</tt> to simply create more than one <tt>Type</tt> right away, and register them all directly with <tt>Type_registerType</tt>, needing no obtainer function. An example is the <tt>TypeClass</tt> representing <tt>java.sql.Timestamp</tt>, which creates two <tt>Type</tt> instances and registers them immediately, one each for the PostgreSQL <tt>timestamp</tt> and <tt>timestamptz</tt> types, as both are mapped to this Java class by default.</p></div>
<div class="section">
<h4><a name="Exceptional_behavior_of_String"></a>Exceptional behavior of <tt>String</tt></h4>
<p>At the other extreme, the <tt>TypeClass</tt> for <tt>String</tt> provides an obtainer that will supply a <tt>Type</tt> for any PostgreSQL type it is asked to, and will rely on the PostgreSQL text input and output methods for that type to handle the conversion. This is how it is possible in PL/Java to request or supply a <tt>String</tt> whatever the underlying PostgreSQL type.</p>
<p>The obtainer for <tt>String</tt>, at present, does not do any bookkeeping to return one <tt>Type</tt> per PostgreSQL type oid it is called for. It simply allocates a new one on every call. That makes it an exception to the <a class="externalLink" href="https://github.com/tada/pljava/blob/d2285d74/src/C/include/pljava/type/Type.h#L105">comment in <tt>Type.h</tt></a> specifying singleton behavior, but the exception is as ancient as the comment.</p></div>
<div class="section">
<h4><a name="Obtainer_vs._direct_registration"></a>Obtainer vs. direct registration</h4>
<p>In the more common case where a <tt>TypeClass</tt> will only sensibly have a few <tt>Type</tt> children, the choice to simply create and register those directly or to use a <tt>TypeObtainer</tt> can be influenced by a few considerations.</p>
<p>The <tt>TypeClass</tt> for <tt>java.sql.Timestamp</tt> directly registers its two children because it is the default mapping according to JDBC for both PostgreSQL types <tt>timestamp</tt> and <tt>timestamptz</tt>. The two <tt>Type</tt>s are directly registered, keyed by those two type oids, and directly retrieved from the cache when a PostgreSQL value of either type has to be mapped.</p>
<p>In contrast, JDBC 4.2 introduced non-default mappings for both SQL types: a <tt>timestamp</tt> can map to a <tt>java.time.LocalDateTime</tt>, and a <tt>timestamptz</tt> can map to a <tt>java.time.OffsetDateTime</tt>, but only when the Java code explicitly requests. So, the <tt>TypeClass</tt> for <tt>LocalDateTime</tt> does not directly register a <tt>Type</tt> corresponding to SQL <tt>timestamp</tt>. It registers a type obtainer, which can only return a singleton <tt>Type</tt> for that exact SQL type, and does so when asked.</p>
<p>For the same reason, the <tt>TypeClass</tt> for <tt>SQLXML</tt> relies on an obtainer. Although an alternate mapping for the <tt>text</tt> type, it would normally be the default mapping for type <tt>xml</tt> according to JDBC 4, and would simply register that <tt>Type</tt> directly. However, PL/Java has long mapped the <tt>xml</tt> type to <tt>String</tt> by default, so for now (until a later, major release), it treats <tt>SQLXML</tt> as an alternative mapping Java code may explicitly use.</p></div>
<div class="section">
<h4><a name="Lazy_initialization"></a>Lazy initialization</h4>
<p>In the case of the new JDBC 4.2 date/time optional mappings, there is another reason for each new <tt>TypeClass</tt> to provide a <tt>TypeObtainer</tt>, even though each <tt>TypeObtainer</tt> will only support exactly one PostgreSQL type. The corresponding Java classes do not exist before Java 8, and PL/Java supports earlier releases, so it cannot unconditionally load those classes at initialization time. Each corresponding <tt>TypeClass</tt> defers that part of its initialization to the first call of its obtainer, which only happens if the Java code has referred to the class and therefore it&#x2019;s known to exist.</p>
<p>A side benefit of this approach is laziness in its own right: less class loading done at initialization before even knowing whether the classes will be needed. In future work, it may be possible to further reduce PL/Java&#x2019;s time-to-first-result by applying the technique more widely to types that use direct registration now.</p></div>
<div class="section">
<h4><a name="Type_canReplaceType"></a><tt>Type_canReplaceType</tt></h4>
<p>When there is a registered default mapping from a PostgreSQL type to a <tt>Type</tt> <i>a</i>, and the Java type associated with that <tt>TypeClass</tt> is not the one used in the Java code, the Java type expected by the code will be looked up and resolved to a <tt>TypeClass</tt>, and from there by its type obtainer to a second <tt>Type</tt> <i>b</i>. The <tt>Type_canReplaceType</tt> method of <i>b</i> will be called, passing <i>a</i>. If it returns <tt>true</tt>, the <tt>Type</tt> <i>b</i> and its methods will be used instead of <i>a</i> to handle the coercions from PostgreSQL <tt>Datum</tt> to Java type and vice versa. Otherwise, PL/Java will seek a chain of PostgreSQL type coercions to bridge the gap.</p>
<p>The design is slightly awkward at present, because <tt>Type_canReplaceType</tt> is applied to two <tt>Type</tt>s (or has one as receiver and one as argument, in the &#x201c;C objects&#x201d; view), so it has to be applied to the result, <i>b</i>, of the type obtainer, essentially to find out whether calling that obtainer was worth doing. A simpler design might result by changing its argument to a <tt>TypeClass</tt>.</p>
<p>In the current design, redundant checks are largely avoided by not expecting the type obtainer to do error reporting. If it supports more than one PostgreSQL type, it should use the PostgreSQL type oid that is passed to determine which <tt>Type</tt> instance to return. If the PostgreSQL oid is not one of those, it should simply return whichever <tt>Type</tt> instance represents its primary or most natural mapping. It does not need to report that the PostgreSQL oid is unsupported; it can leave that to its can-replace method. A corollary is that a type obtainer supporting exactly one PostgreSQL type may return its singleton <tt>Type</tt> instance unconditionally, ignoring its argument.</p></div>
<div class="section">
<h4><a name="Coercions"></a>Coercions</h4>
<p>Each C <tt>Type</tt> has a method <tt>coerceDatum</tt> that takes a PostgreSQL <tt>Datum</tt> and produces the corresponding Java value, and a method <tt>coerceObject</tt> that does the reverse. There are also <tt>invoke*</tt> methods provided on <tt>Type</tt>. The convention is that the actual invocation of a function goes through the subclass of <tt>Type</tt> that represents the function&#x2019;s return type.</p></div></div></div>
<div class="section">
<h2><a name="When_type_coercions_can_take_place"></a>When type coercions can take place</h2>
<p>SQL types can be converted to Java objects or the reverse in several different contexts.</p>
<div class="section">
<h3><a name="Parameters_and_return_values_when_calling_a_PLJava_function_from_SQL"></a>Parameters and return values when calling a PL/Java function from SQL</h3>
<p>These are the usual rules for converting function parameters from the types used in the function&#x2019;s SQL declaration to the types of the underlying Java method&#x2019;s signature, and the Java method&#x2019;s return type to the return type in the SQL declaration. They do not apply to the special cases where a composite type is passed or returned, which are seen by the Java code as JDBC result sets.</p>

<ol style="list-style-type: decimal">
  
<li>
<p>A C <tt>Type</tt> subclass is looked up for the SQL type name declared for the parameter or return type, using the fixed mappings registered during PL/Java initialization (see calls to <tt>Type_registerType</tt> in the code).</p></li>
  
<li>
<p>If this search has not produced a <tt>Type</tt> (after forming an array type where necessary, or replacing a domain with its base type), the type map is consulted, which may result in a new <tt>UDT</tt> subclass being registered that handles the conversion between a PostgreSQL <tt>Datum</tt> and the associated Java class.</p></li>
  
<li>
<p><i>If the function&#x2019;s <tt>AS</tt> clause only names a method, without parameter or return type signatures,</i> the Java types that correspond to the <tt>Type</tt> objects chosen at this stage are used to construct a signature for the Java method. The method to be used must have the given name and exact signature, or one replacing a primitive return type with its boxed form, or one with <tt>ResultSetProvider</tt> replaced with <tt>ResultSetHandle</tt>. Either the matching method is found at this step, or the call fails.</p></li>
  
<li>
<p><i>If the function&#x2019;s <tt>AS</tt> clause includes Java types for the parameters and/or return type,</i> they are compared (textually) to the signature that would have been generated. If they all match, the method is resolved in the same way as if the signature had not been included.</p></li>
  
<li>
<p>For any Java type in the explicit method signature that differs from the the one that corresponds to the C <tt>Type</tt> subclass so far chosen, another C <tt>Type</tt> is looked up using the explicit Java type as the key. If that <tt>Type</tt> is usable in place of the one earlier chosen (as determined by the <tt>Type_canReplaceType</tt> method), it will be used. Otherwise, a <tt>Coerce</tt> type is generated according to PostgreSQL&#x2019;s <tt>find_coercion_pathway</tt> function, which uses all of PostgreSQL&#x2019;s configured type-casting rules to find a suitable conversion.</p></li>
</ol>
<p>That final step is roughly equivalent to inserting an SQL <tt>CAST</tt>. However, two of PostgreSQL&#x2019;s possible casting strategies are not currently handled by PL/Java, namely array coercions, and coercions by going through the text output/input functions. Also, if the return type in the SQL declaration is a domain, constraints on the domain are not checked, allowing the function to return values of the base type that should not be possible in the domain. This is a bug.</p></div>
<div class="section">
<h3><a name="A_general_rule_with_one_present_exception"></a>A general rule, with one present exception</h3>
<p>As the steps above reveal, for both directions of conversion, it is the <i>PostgreSQL</i> type that starts the algorithm off. The known mappings are used to find a prospective Java type from it, and then if the actual Java type appearing in the code is not the expected one, plans are adjusted accordingly.</p>
<p>This pattern is seen elsewhere in the ISO SQL standard, in Part 14 on XML-related specifications, which include how to convert values of SQL types to XML Schema data types and the reverse. Again, for both conversion directions, the algorithms begin with the SQL type, then adjust if the prospective mapped type is not the one expected.</p>
<div class="section">
<h4><a name="Parameters_supplied_to_a_JDBC_PreparedStatement_from_Java"></a>Parameters supplied to a JDBC <tt>PreparedStatement</tt> from Java</h4>
<p>The sole exception in PL/Java is the JDBC <tt>PreparedStatement</tt>, and only for the <i>parameters supplied to</i> the statement. <i>Results from it</i> are handled consistently with the general rule.</p>
<p>Ordinarily, when preparing a query that contains parameters, PostgreSQL&#x2019;s parsing and analysis will reach conclusions about what SQL types the parameters will need to have so that the query makes sense. JDBC presents those conclusions to the Java code through the <tt>getParameterMetaData</tt> method once the query has been prepared, so that the Java code can supply values of appropriate types, or necessary coercions can be done. The (client side) pgJDBC driver is able to implement <tt>getParameterMetaData</tt> because the PostgreSQL frontend-backend protocol allows for sending a query to prepare and having the server send back a <tt>ParameterDescription</tt> message with the needed type information.</p>
<p>For curious historical reasons, PostgreSQL has been able to supply remote clients with that <tt>ParameterDescription</tt> information since PG 7.4 came out in 2003, but a module <i>loaded right inside the backend</i> like PL/Java could not request the same information using SPI until PG 9.0 in 2010, and <a class="externalLink" href="https://www.postgresql.org/message-id/874liv1auh.fsf%40news-spur.riddles.org.uk">still not easily</a>. By then, PL/Java had long been &#x2018;faking&#x2019; <tt>ParameterMetaData</tt> in a way that reverses the usual type mapping pattern.</p></div>
<div class="section">
<h4><a name="How_ParameterMetaData_gets_faked"></a>How <tt>ParameterMetaData</tt> gets faked</h4>
<p>PL/Java, when creating a <tt>PreparedStatement</tt>, does not submit the query immediately to PostgreSQL for analysis. Instead, it initializes all of the parameter types to unknown, and allows the Java code to go ahead and call the <tt>set...()</tt> methods to supply values. Using the supplied <i>Java</i> types as starting points, it fills in the parameter types by following the usual mappings backward. If the Java code does, in fact, call <tt>getParameterMetaData</tt>, PL/Java returns the types determined that way for any parameters that have already been set, and (arbitrarily) <tt>VARCHAR</tt> for any that have not. Only when the Java code executes the statement the first time does PL/Java submit the query to PostgreSQL to prepare, passing along the type mappings assumed so far, and hoping PostgreSQL can make sense of it.</p>
<p>While getting the general rule wrong and differing from client-side pgJDBC, this is not completely unworkable, and has been PL/Java&#x2019;s behavior <a class="externalLink" href="https://github.com/tada/pljava/blob/86793a2f/src/java/org/postgresql/pljava/jdbc/SPIPreparedStatement.java#L425">since 2004</a>. Any resulting surprises can generally be resolved by some rewriting of the query or use of other PL/Java JDBC methods that more directly indicate the intended PostgreSQL types. <a href="../releasenotes.html#Typing_of_parameters_in_prepared_statements">Some small changes in PL/Java 1.5.1</a> may help in some cases. 1.5.1 also introduces <tt>TypeBridge</tt>s, described later on this page.</p>
<p>A future major release of PL/Java should use the additions to PostgreSQL SPI and bring the treatment of <tt>PreparedStatement</tt> parameters into conformance with the general rule. (That release, therefore, will have to support PostgreSQL versions no earlier than 9.0.)</p>
<p>JDBC defines some <tt>setObject</tt> and <tt>setNull</tt> methods on <tt>PreparedStatement</tt> that must be passed a <tt>java.sql.Types</tt> constant. The JDBC constant will be mapped to a PostgreSQL type OID through a fixed mapping coded in <tt>Oid_forSqlType</tt>.</p></div></div>
<div class="section">
<h3><a name="Values_read_or_written_through_the_JDBC_ResultSet_interface"></a>Values read or written through the JDBC <tt>ResultSet</tt> interface</h3>
<p>This case includes not only results from SPI queries made in Java, but also composite function parameters or return values, and <i>old</i> and <i>new</i> tuples in triggers.</p>
<p>Although done in different places in the code (<tt>SPIResultSet</tt>, <tt>Tuple</tt>, <tt>HeapTupleHeader</tt>, <tt>TupleDesc</tt>), these also have the same behavior as the first two rules in the &#x201c;parameters and return values&#x201d; case. Again, see &#x201c;additional JDBC coercions&#x201d; below.</p></div>
<div class="section">
<h3><a name="Values_read_or_written_through_the_JDBC_SQLInputSQLOutput_interfaces"></a>Values read or written through the JDBC <tt>SQLInput</tt>/<tt>SQLOutput</tt> interfaces</h3>
<p>These are used in PL/Java&#x2019;s implementation of user-defined types. There are three distinct flavors of user-defined type that PL/Java can manage. <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base types</a> and <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">composite types</a> are established terms in PostgreSQL. <i>Mirrored type</i> is a term invented just now to denote that other thing PL/Java can do.</p>

<dl>
<dt><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base type</a> a/k/a scalar type</dt>
<dd>A type declared with the <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">no-<tt>AS</tt> form of <tt>CREATE TYPE</tt></a>, integrating into the PostgreSQL type system at the lowest level. The implementation controls its stored size and format and its text input and output syntax. The fact that the type is implemented in Java is transparent and it can be used from SQL like any other type. For access to the storage area, Java code is provided <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations that act as raw memory buffer accessors with methods to read and write common types of various widths. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT</a> annotation.</dd>
<dt><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">Composite type</a></dt>
<dd>A type declared with the <a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249"><tt>AS</tt> (list of named typed attributes) form of <tt>CREATE TYPE</tt></a>, which can then be associated with a Java class using <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String">SQLJ.ADD_TYPE_MAPPING</a>. From outside of Java code, it can be manipulated like any PostgreSQL composite type, while to Java code it will be presented as an instance of the associated Java class&#x2014;a new instance at every conversion, however. Java code is provided <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations that retrieve and set the typed attributes of the composite. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> annotation having a <tt>structure</tt> attribute.</dd>
<dt>Mirrored type</dt>
<dd>An existing PostgreSQL type that is outside of the standard SQL types that have pre-registered PL/Java <tt>Type</tt> mappings, but has been associated with a Java class through use of <a href="../pljava/apidocs/index.html?org/postgresql/pljava/management/Commands.html#addTypeMappingjava.lang.String20java.lang.String">SQLJ.ADD_TYPE_MAPPING</a>. The Java code is provided the same raw-memory-accessing <tt>SQLInput</tt> and <tt>SQLOutput</tt> implementations as for a base type, and the developer must understand and match the stored form of the existing type. This can be a brittle design to maintain. Because PL/Java consults the type map only if the first step of <tt>Type</tt> lookup fails, standard SQL types like <tt>integer</tt> cannot be mirrored this way. Created by a Java class with the <a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> annotation having no <tt>structure</tt> attribute, and naming an existing PostgreSQL type.</dd>
</dl>
<p><i>Note: the presence of absence of a <tt>structure</tt> attribute in a <tt>@MappedUDT</tt> annotation only determines whether the SQL generator emits a <tt>CREATE TYPE</tt> declaring the structure, as well as the <tt>SQLJ.ADD_TYPE_MAPPING</tt> call (which is always emitted) to associate the class. The <tt>@MappedUDT</tt> annotation could also be used with no <tt>structure</tt> attribute and the name of an existing composite type, to associate that type with a Java class. This would act as a composite type (with <tt>SQLInput</tt>/<tt>SQLOutput</tt> working in typed-tuple mode), even though it could also be described as mirroring an existing type.</i></p>

<table border="0" class="bodyTable"><caption>Summary</caption>
  <thead>
    
<tr class="a">
      
<th> </th>
      
<th align="center"><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80283">Base type</a> </th>
      
<th align="center"><a class="externalLink" href="http://www.postgresql.org/docs/current/static/sql-createtype.html#AEN80249">Composite type</a> </th>
      
<th align="center">Mirrored type </th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>Annotate</b> </td>
      
<td align="center"><a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/BaseUDT.html">@BaseUDT</a> </td>
      
<td align="center" colspan="2"><a href="../pljava-api/apidocs/index.html?org/postgresql/pljava/annotation/MappedUDT.html">@MappedUDT</a> </td>
    </tr>
    
<tr class="a">
      
<td><b>Stored form</b> </td>
      
<td align="center">Raw (Java controls) </td>
      
<td align="center">Tuple </td>
      
<td align="center">Native (Java must match) </td>
    </tr>
    
<tr class="b">
      
<td><b>SQLInput/SQLOutput mode</b> </td>
      
<td align="center">Raw buffer </td>
      
<td align="center">Typed tuple </td>
      
<td align="center">Raw buffer </td>
    </tr>
  </tbody>
  
</table>
<div class="section">
<h4><a name="SQLInputSQLOutput_in_typed_tuple_mode"></a><tt>SQLInput</tt>/<tt>SQLOutput</tt> in typed tuple mode</h4>
<p>In this mode, values read or written through this interface get the same treatment they would from a JDBC <tt>ResultSet</tt>, converted according to the first two rules set out above.</p></div>
<div class="section">
<h4><a name="SQLInputSQLOutput_in_raw_memory_access_mode"></a><tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw memory access mode</h4>
<p>In this mode, SQL-specific conversions are not performed, and many of the SQL-specific <tt>read...</tt> and <tt>write...</tt> methods are disabled (throwing an exception for unsupported operation), leaving mostly those for common Java types with familiar widths and formats. The <tt>wasNull</tt> method always returns <tt>false</tt>. The methods for <tt>Byte</tt>, <tt>Short</tt>, <tt>Int</tt>, and <tt>Long</tt> deal directly in 1, 2, 4, or 8-octet fields, as with the methods for other fixed-width types. The methods for variable-length fields (<tt>BigDecimal</tt>, <tt>BinaryStream</tt>, <tt>Bytes</tt>, <tt>CharacterStream</tt>, <tt>String</tt>, and <tt>URL</tt>) all share a 16-bit-length-prefixed format allowing up to 65535 bytes in the field.</p>

<table border="0" class="bodyTable"><caption>Formats used by <tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw mode. <tt>pfx</tt> is variable length with 2-octet count.</caption>
  <thead>
    
<tr class="a">
      
<th align="right"><tt>read</tt>/<tt>write...</tt> method </th>
      
<th align="center">acts on </th>
      
<th align="left">notes </th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td align="right"><tt>Array</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>AsciiStream</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>BigDecimal</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">as via *<tt>String</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>BinaryStream</tt> </td>
      
<td align="center">pfx </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Blob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Boolean</tt> </td>
      
<td align="center">1 octet </td>
      
<td align="left"><tt>!= 0</tt>, written as <tt>1</tt> or <tt>0</tt></td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Byte</tt> </td>
      
<td align="center">1 octet </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Bytes</tt> </td>
      
<td align="center">pfx </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>CharacterStream</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">as via *<tt>String</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Clob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Date</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Double</tt> </td>
      
<td align="center">8 octets </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Float</tt> </td>
      
<td align="center">4 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Int</tt> </td>
      
<td align="center">4 octets </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Long</tt> </td>
      
<td align="center">8 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>NClob</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>NString</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Object</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Ref</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>RowId</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Short</tt> </td>
      
<td align="center">2 octets </td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>SQLXML</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>String</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">always <tt>UTF-8</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Struct</tt> </td>
      
<td align="center">unsupported </td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>Time</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="a">
      
<td align="right"><tt>Timestamp</tt> </td>
      
<td align="center">8 octets </td>
      
<td align="left"><tt>getTime()</tt> as <tt>long</tt></td>
    </tr>
    
<tr class="b">
      
<td align="right"><tt>URL</tt> </td>
      
<td align="center">pfx </td>
      
<td align="left">via *<tt>String</tt></td>
    </tr>
  </tbody>
  
</table>
<p><i>Note: in all PL/Java versions to and including <tt>1.5.0-BETA2</tt>, the <tt>SQLInput</tt>/<tt>SQLOutput</tt> methods for types wider than a byte are bigendian, regardless of the underlying hardware.</i></p>
<p>For mirrored types, this is plainly a bug: when running on little-endian hardware, PostgreSQL and Java will disagree on what the values are.</p>
<p>For base types there is no disagreement issue (because <i>only</i> the Java code manipulates those), though there may be a slight performance cost. In release 1.5.0, byte order is selectable. For mirrored types, the default has changed to <tt>native</tt>. For base types, the default stays <tt>big_endian</tt>, to preserve the values of any existing user-defined types stored with earlier PL/Java versions, and to preserve their <tt>COPY</tt> and on-network binary form.</p>
<p>Because of the &#x201c;UDT function slot switcheroo&#x201d; (described further below), PL/Java UDTs implicitly have a binary send/receive/<tt>COPY</tt> form reflecting their internal stored representation; they cannot, at present, use the send and receive function slots to define a custom format for binary transfer. Because the <a class="externalLink" href="http://www.postgresql.org/docs/8.2/static/sql-copy.html#AEN46503">binary <tt>COPY</tt> format documentation</a> specifies network byte order (that is, big-endian), there are no plans to change the default stored form from <tt>big_endian</tt> until some future release decouples the stored representation from that for binary transfer.</p>
<p>In some future upgrade, it may be appropriate to change the byte order for base types, which will require a migration step for any stored data of PL/Java base types. Methods for doing that are covered on the <a href="../use/byteorder.html">byte order page</a>.</p></div></div></div>
<div class="section">
<h2><a name="Additional_JDBC_coercions"></a>Additional JDBC coercions</h2>
<p>The JDBC standard facilities for managing a type map are not implemented or used, and <tt>getTypeMap</tt> will always return <tt>null</tt>. All of PL/Java&#x2019;s uses of the type map managed with <tt>SQLJ.ADD_TYPE_MAPPING</tt> take place below the level of the JDBC mechanisms.</p>
<p>When reading or writing values through any of the JDBC interfaces (except <tt>SQLInput</tt>/<tt>SQLOutput</tt> in raw mode), there is another layer of type coercion that can be applied, after (when reading) or before (when writing) the rules presented above, and unrelated to them. These are implemented entirely in Java, and can be found in <tt>SPIConnection.java</tt> under the names <tt>basicCoersion</tt>, <tt>basicNumericCoersion</tt>, and <tt>basicCalendricalCoersion</tt>.</p>
<p>These three, however, are inconsistently applied. They are used on values written by Java to the single-row writable <tt>ResultSet</tt>s that PL/Java provides for composite function results, but not those written to the similar <tt>ResultSet</tt>s provided to triggers, or prepared statement parameters, or <tt>SQLOutput</tt> in typed tuple mode. They also cannot be assumed to cover all cases since JDBC 4.1 and 4.2 introduced new type mappings that can be used in place of the default ones (such as <tt>java.time.OffsetTime</tt> for <tt>timetz</tt>).</p>
<p>Therefore, a future PL/Java release will probably phase out those three methods in favor of a more general method.</p></div>
<div class="section">
<h2><a name="The_TypeBridge_class"></a>The <tt>TypeBridge</tt> class</h2>
<p>A start on the replacement of those three methods has already been made in the work to support the <tt>java.time</tt> types and <tt>SQLXML</tt> in PL/Java 1.5.1. The support of these alternative mappings requires that the Java types be recognized as alternate mappings known to the native code, and passed intact to the native layer with no attempt to coerce them to the expected types first. To do that, a Java value that is of one of the known supported alternate types is wrapped in a <tt>TypeBridge.Holder</tt> to link the value with explicit information on the needed type conversion. As the first step in phasing out the inconsistently-applied <tt>SPIConnection</tt> basic coercions, they are never applied at all to a <tt>TypeBridge.Holder</tt>. At present, <tt>TypeBridge</tt>s are used only for the newly-added type mappings, to avoid a behavior change for pre-existing ones.</p>
<p>The <tt>TypeBridge</tt> class is not intended as a mechanism for user-extensible type mappings (the existing facilities for user-defined types should be used). There will be a small, stable number of <tt>TypeBridge</tt>s corresponding to known type mappings added in the JDBC spec, or otherwise chosen for native support in PL/Java. For any <tt>TypeBridge</tt> wrapping a Java value there must be a native-code <tt>TypeClass</tt> registered for the Java class the bridge is meant to carry. There is one function in <tt>Type.c</tt> to initialize and register all of the known handful of <tt>TypeBridge</tt>s. When new ones are added, the list must be kept in an order such that if bridge <i>a</i> is registered before bridge <i>b</i>, then <i>a</i> will not capture the Java type registered to <i>b</i>.</p></div>
<div class="section">
<h2><a name="The_user-defined-type_function_slot_switcheroo"></a>The user-defined-type function slot switcheroo</h2>
<p>When a new base type is defined in PostgreSQL, the <tt>CREATE TYPE</tt> command can specify four functions that deal directly with the type representation: <tt>INPUT</tt> and <tt>OUTPUT</tt>, which convert between the internal representation and printable/parsable text form, and <tt>RECEIVE</tt> and <tt>SEND</tt>, normally used to offer another transfer format, more efficient than text, to pass over the channel between frontend and backend.</p>
<p>When a new base UDT is defined in PL/Java, the generated <tt>CREATE TYPE</tt> command fills those four function slots, but with functions whose <tt>AS</tt> strings do not directly name the Java methods to call. Instead, the strings have a special form identifying the Java class associated with the type, and the slot type, <tt>INPUT</tt>/<tt>OUTPUT</tt>/<tt>SEND</tt>/<tt>RECEIVE</tt>. When PostgreSQL calls these &#x201c;functions&#x201d;, the PL/Java runtime passes control appropriately; there are fixed names and signatures for the four methods that the associated class needs to implement.</p>
<p>The semantics of the four slots are slightly reinterpreted. <tt>INPUT</tt> and <tt>OUTPUT</tt> still implement the type&#x2019;s outward, textual form, but instead of converting between that form and the form PostgreSQL sees, they convert between the text form and an instance of the Java class (using the methods <tt>parse</tt> and <tt>toString</tt>, respectively).</p>
<p>It would be natural to expect that the other two slots, <tt>RECEIVE</tt> and <tt>SEND</tt>, correspond to the other two required Java methods, <tt>readSQL</tt> and <tt>writeSQL</tt>, but they do not exactly. The <tt>readSQL</tt> and <tt>writeSQL</tt> are actually called only from the coercion methods of <tt>UDT</tt> (in PL/Java&#x2019;s C &#x201c;object&#x201d; system, a subclass of <tt>Type</tt>) when PL/Java needs to convert between a Java class instance and the PostgreSQL stored type, <i>not</i> from <tt>Function</tt> when PostgreSQL has called through the <tt>RECEIVE</tt> or <tt>SEND</tt> slot in order to transport the value between backend and frontend. This is the type-function-slot switcheroo.</p>
<p>That repurposing of the <tt>RECEIVE</tt> and <tt>SEND</tt> slots does not leave a way to name special functions for binary transport to the frontend, so whenever PostgreSQL does call through those slots, PL/Java always does a raw binary transfer using the <tt>libpq</tt> API directly (for fixed-size representations), <tt>bytearecv</tt>/<tt>byteasend</tt> for <tt>varlena</tt> representations, or <tt>unknownrecv</tt>/<tt>unknownsend</tt> for C string representations.</p>
<p>A future version could revisit this limitation, and allow PL/Java UDTs to specify custom binary transfer formats also.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2003&#x2013;2019
                        <a href="http://tada.se/eng/">Tada AB</a>.
            All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
